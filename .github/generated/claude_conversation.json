{
  "timestamp": "2025-01-24T15:42:16.106930",
  "issue_number": "3",
  "system_prompt": "You are a helpful AI assistant that generates code based on GitHub issues. \n        Your task is to:\n        1. Analyze the issue description and comments\n        2. Generate or modify the requested files\n        3. Include necessary imports and documentation\n        4. Return complete, working code files\n        \n        IMPORTANT: For each file, you must format your response exactly like this:\n        ```language:full/path/to/file\n        [file contents here]\n        ```\n        \n        For example:\n        ```yaml:.github/workflows/example.yml\n        name: Example Workflow\n        on: push\n        ```\n        \n        ```python:.github/scripts/example.py\n        import os\n        def main():\n            pass\n        ```\n        \n        Do not include any explanations or markdown formatting outside the code blocks.",
  "user_prompt": "Generate or modify the following files based on this issue:\n\nHere are the files that need to be created or modified:\n\nExisting file .github/scripts/ct_to_text.py:\n```\n#!/usr/bin/env python3\n\nimport os\nimport re\nimport sys\n\ntry:\n    from openai import OpenAI\nexcept ImportError:\n    print(\"Error: The 'openai' library (or your custom O1-mini package) is missing.\")\n    sys.exit(1)\n\n# We assume you set OPENAI_API_KEY in your GitHub Actions environment\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\", \"\")\n\n# Regex to detect lines like \"New Record #104236 Title: Endocast [Mesh] [CT]\"\nRE_RECORD_HEADER = re.compile(r'^New Record #(\\d+)\\s+Title:\\s*(.*)$', re.IGNORECASE)\n\ndef parse_records_from_body(body: str):\n    \"\"\"\n    Parses the release body, looking for lines like:\n      New Record #XXXX Title: ...\n    Then captures subsequent lines of the form 'Key: Value', e.g.:\n      Detail Page URL: ...\n      Object: ...\n      Taxonomy: ...\n      etc.\n\n    Returns a list of dicts, each representing a record's data:\n      {\n        \"record_number\": \"104236\",\n        \"title\": \"Endocast [Mesh] [CT]\",\n        \"detail_url\": \"...\",\n        \"Object\": \"...\",\n        \"Taxonomy\": \"...\",\n        ...\n      }\n    \"\"\"\n    records = []\n    lines = body.splitlines()\n    current_record = {}\n\n    for line in lines:\n        line = line.strip()\n        # Skip empty lines\n        if not line:\n            continue\n\n        # See if this line starts a new record\n        match = RE_RECORD_HEADER.match(line)\n        if match:\n            # If we already have a record in progress, finalize it\n            if current_record:\n                records.append(current_record)\n            current_record = {}\n            current_record[\"record_number\"] = match.group(1)\n            current_record[\"title\"] = match.group(2)\n            continue\n\n        # Otherwise, if line looks like \"SomeKey: SomeValue\"\n        if \":\" in line:\n            parts = line.split(\":\", 1)\n            key = parts[0].strip()\n            val = parts[1].strip()\n            kl = key.lower()\n\n            # We can store known fields in canonical keys\n            if kl.startswith(\"detail page url\"):\n                current_record[\"detail_url\"] = val\n            elif kl == \"object\":\n                current_record[\"Object\"] = val\n            elif kl == \"taxonomy\":\n                current_record[\"Taxonomy\"] = val\n            elif kl == \"element or part\":\n                current_record[\"Element or Part\"] = val\n            elif kl == \"data manager\":\n                current_record[\"Data Manager\"] = val\n            elif kl == \"date uploaded\":\n                current_record[\"Date Uploaded\"] = val\n            elif kl == \"publication status\":\n                current_record[\"Publication Status\"] = val\n            elif kl == \"rights statement\":\n                current_record[\"Rights Statement\"] = val\n            elif kl == \"cc license\":\n                current_record[\"CC License\"] = val\n\n            # Also store the raw key-value in case we need it\n            current_record[key] = val\n\n    # After the loop, if there's a record in progress, append it\n    if current_record:\n        records.append(current_record)\n\n    return records\n\ndef generate_text_for_records(records):\n    \"\"\"\n    Calls the o1-mini model (via OpenAI-like usage) to generate a multi-paragraph,\n    ~200-word description for each record, focusing on species/taxonomy and object details.\n    \"\"\"\n    if not OPENAI_API_KEY:\n        return \"Error: OPENAI_API_KEY is missing.\"\n\n    # Initialize the client\n    client = OpenAI(api_key=OPENAI_API_KEY)\n\n    # If no records found, bail out\n    if not records:\n        return \"No new records to summarize.\"\n\n    # Build a user prompt that includes each record's metadata\n    user_content = [\"Below are new CT records from a MorphoSource release:\\n\"]\n    for rec in records:\n        record_num = rec.get(\"record_number\", \"N/A\")\n        user_content.append(f\"Record #{record_num}:\")\n        user_content.append(f\" - Title: {rec.get('title','N/A')}\")\n        user_content.append(f\" - URL: {rec.get('detail_url','N/A')}\")\n\n        for field in [\n            \"Object\",\n            \"Taxonomy\",\n            \"Element or Part\",\n            \"Data Manager\",\n            \"Date Uploaded\",\n            \"Publication Status\",\n            \"Rights Statement\",\n            \"CC License\",\n        ]:\n            if field in rec:\n                user_content.append(f\" - {field}: {rec[field]}\")\n        user_content.append(\"\")  # Blank line separator\n\n    # Add instructions for a ~200-word multi-paragraph summary\n    user_content.append(\n        \"You are a scientific writer with expertise in analyzing morphological data. \"\n        \"You have received metadata from X-ray computed tomography scans of various biological specimens. \"\n        \"Please compose a multi-paragraph, one for each record/species, ~200-word plain-English description that \"\n        \"emphasizes each specimen\u2019s species (taxonomy) and object details. Focus on identifying notable anatomical \"\n        \"or morphological features that may be revealed by the CT scanning process. Avoid discussions of copyright \"\n        \"or publication status. Make the final description readable for a broad audience, yet scientifically informed. \"\n        \"Highlight the significance of the scans for understanding the organism\u2019s structure and potential insights \"\n        \"into its biology or evolution.\"\n    )\n\n    try:\n        resp = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": \"\\n\".join(user_content)\n                        }\n                    ]\n                }\n            ]\n        )\n        return resp.choices[0].message.content.strip()\n    except Exception as e:\n        return f\"Error calling o1-mini model: {e}\"\n\ndef main():\n    \"\"\"\n    1. Reads a single argument <release_body_file>\n    2. Parses it for \"New Record #...\" blocks\n    3. Calls generate_text_for_records(records) to produce a multi-paragraph text\n    4. Prints the final text to stdout\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: ct_to_text.py <release_body_file>\")\n        sys.exit(1)\n\n    release_body_file = sys.argv[1]\n    if not os.path.isfile(release_body_file):\n        print(f\"File '{release_body_file}' not found.\")\n        sys.exit(1)\n\n    with open(release_body_file, \"r\", encoding=\"utf-8\") as f:\n        body = f.read()\n\n    # Parse records\n    records = parse_records_from_body(body)\n    # Generate final text using the o1-mini model\n    description = generate_text_for_records(records)\n    print(description)\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\nExisting file .github/workflows/ct_to_text.yml:\n```\nname: CT to Text\n\non:\n  workflow_run:\n    # Must match the 'name:' from your parse_morphosource_data.yml\n    workflows: [\"Parse MorphoSource Data\"]\n    types: [completed]\n\njobs:\n  ct_text_job:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n      # -------------------------------------------------------\n      # 1. Check out your repository\n      # -------------------------------------------------------\n      - name: Check out repo\n        uses: actions/checkout@v3\n\n      # -------------------------------------------------------\n      # 2. Set up Python\n      # -------------------------------------------------------\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      # -------------------------------------------------------\n      # 3. Install Dependencies\n      # -------------------------------------------------------\n      - name: Install Dependencies\n        run: pip install requests beautifulsoup4 openai\n\n      # -------------------------------------------------------\n      # 4. Fetch Latest Release (multi-line safe)\n      # -------------------------------------------------------\n      - name: Fetch Latest Release\n        id: fetch_release\n        env:\n          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}\n        run: |\n          echo \"Fetching the latest release from this repo...\"\n          response=$(curl -sSL -H \"Authorization: Bearer $GITHUB_TOKEN\" \\\n            https://api.github.com/repos/${{ github.repository }}/releases/latest)\n\n          # (Optional) Save JSON for debugging\n          echo \"$response\" > latest_release.json\n\n          # Extract fields\n          body=$(echo \"$response\" | python -c \"import sys, json; print(json.load(sys.stdin)['body'])\")\n          tag_name=$(echo \"$response\" | python -c \"import sys, json; print(json.load(sys.stdin)['tag_name'])\")\n\n          echo \"Found release tag_name=$tag_name\"\n\n          # Store them as outputs for subsequent steps\n          # Use multi-line safe approach for release_body\n          echo \"release_body<<EOF\" >> \"$GITHUB_OUTPUT\"\n          echo \"$body\" >> \"$GITHUB_OUTPUT\"\n          echo \"EOF\" >> \"$GITHUB_OUTPUT\"\n\n          # tag_name should be a single line\n          echo \"release_tag=$tag_name\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 5. Check if morphosource-updates\n      # -------------------------------------------------------\n      - name: Check if morphosource-updates\n        id: check_morpho\n        run: |\n          TAG_NAME=\"${{ steps.fetch_release.outputs.release_tag }}\"\n          echo \"Found TAG_NAME=$TAG_NAME\"\n\n          if [[ \"$TAG_NAME\" == morphosource-updates-* ]]; then\n            echo \"is_morphosource=true\" >> \"$GITHUB_OUTPUT\"\n          else\n            echo \"is_morphosource=false\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      # -------------------------------------------------------\n      # 6. Generate Timestamp (Only if it's morphosource-updates)\n      # -------------------------------------------------------\n      - name: Generate Timestamp\n        id: gen_ts\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        run: |\n          # Example format: YYYY-MM-DD_HH-MM-SS\n          TS=$(date +'%Y-%m-%d_%H-%M-%S')\n          echo \"timestamp=$TS\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 7. Run CT to Text (Only if it's morphosource-updates)\n      # -------------------------------------------------------\n      - name: Run CT to Text\n        id: ct2text\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        env:\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n        run: |\n          # Write the release body to a file\n          echo \"${{ steps.fetch_release.outputs.release_body }}\" > release_body.txt\n\n          # Run your custom Python script\n          python .github/scripts/ct_to_text.py release_body.txt > ct_output.txt\n\n          # Export the script output (multi-line safe)\n          echo \"description<<EOF\" >> \"$GITHUB_OUTPUT\"\n          cat ct_output.txt >> \"$GITHUB_OUTPUT\"\n          echo \"EOF\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 8. Create or Update Release with AI Summary\n      # -------------------------------------------------------\n      - name: Create or Update Release with AI Summary\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}\n        with:\n          tag_name: \"ct_to_text_analysis-${{ steps.gen_ts.outputs.timestamp }}\"\n          release_name: \"CT to Text Analysis #${{ steps.gen_ts.outputs.timestamp }}\"\n          body: ${{ steps.ct2text.outputs.description }}\n          draft: false\n          prerelease: false\n\n      # -------------------------------------------------------\n      # 9. Fallback step if not morphosource-updates\n      # -------------------------------------------------------\n      - name: No new morphosource release\n        if: steps.check_morpho.outputs.is_morphosource == 'false'\n        run: echo \"No 'morphosource-updates-*' release found. Skipping CT-to-text analysis.\"\n\n```\n\n\nIssue details:\nIssue Title: CT to Text\n\nIssue Description:\n>handle 2 record error\r\n>adjust prompt for 1 vs. multi record\n\nComment by johntrue15:\n[CT to Text Analysis #2025-01-21_16-53-19](https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/ct_to_text_analysis-2025-01-21_16-53-19)\n\nEchovenator sandersi \u2013 Left Periotic\nThe CT scan of the left periotic bone of Echovenator sandersi offers a detailed glimpse into the intricate ear structures of this extinct species. Echovenator sandersi, a member of the cetacean family, showcases specialized adaptations in its periotic bone, which plays a crucial role in hearing and balance. The high-resolution imaging reveals the complex internal cavities and canaliculi that suggest advanced auditory capabilities, possibly finely tuned for echolocation in its aquatic environment. Notable features include the well-developed cochlear structures, which indicate a sophisticated hearing range, and the intricate connections to the vestibular system, highlighting enhanced balance mechanisms essential for navigating underwater. Additionally, the morphology of the periotic bone may provide insights into the evolutionary pathways of cetaceans, illustrating how specific adaptations have enabled these mammals to thrive in diverse marine habitats. This CT scan not only preserves the delicate details of the bone's architecture but also serves as a valuable resource for paleontologists and evolutionary biologists aiming to reconstruct the sensory and ecological dynamics of ancient marine ecosystems.\n\n**Incomplete Record Information\nThe first record provided lacks essential details necessary for a comprehensive analysis. With the title and URL marked as \"N/A,\" there is insufficient information to describe the specimen or its specific anatomical features. To facilitate a meaningful interpretation of the morphological data, additional metadata such as the species name, object description, and any associated imagery would be required. Ensuring complete and accurate records is vital for the effective study and understanding of biological specimens, as it allows researchers to accurately assess and compare morphological characteristics. If further information becomes available, a more detailed and informative description can be developed to highlight the significance of the specimen within its taxonomic context and its potential contributions to scientific knowledge.**\n\nComment by johntrue15:\nCode Needed:\n.github/scripts/ct_to_text.py\n.github/workflows/ct_to_text.yml\n\n\n",
  "claude_response": "```python:.github/scripts/ct_to_text.py\n#!/usr/bin/env python3\n\nimport os\nimport re\nimport sys\n\ntry:\n    from openai import OpenAI\nexcept ImportError:\n    print(\"Error: The 'openai' library (or your custom O1-mini package) is missing.\")\n    sys.exit(1)\n\n# We assume you set OPENAI_API_KEY in your GitHub Actions environment\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\", \"\")\n\n# Regex to detect lines like \"New Record #104236 Title: Endocast [Mesh] [CT]\"\nRE_RECORD_HEADER = re.compile(r'^New Record #(\\d+)\\s+Title:\\s*(.*)$', re.IGNORECASE)\n\ndef parse_records_from_body(body: str):\n    \"\"\"\n    Parses the release body, looking for lines like:\n      New Record #XXXX Title: ...\n    Then captures subsequent lines of the form 'Key: Value', e.g.:\n      Detail Page URL: ...\n      Object: ...\n      Taxonomy: ...\n      etc.\n\n    Returns a list of dicts, each representing a record's data:\n      {\n        \"record_number\": \"104236\",\n        \"title\": \"Endocast [Mesh] [CT]\",\n        \"detail_url\": \"...\",\n        \"Object\": \"...\",\n        \"Taxonomy\": \"...\",\n        ...\n      }\n    \"\"\"\n    records = []\n    lines = body.splitlines()\n    current_record = {}\n\n    for line in lines:\n        line = line.strip()\n        # Skip empty lines\n        if not line:\n            continue\n\n        # See if this line starts a new record\n        match = RE_RECORD_HEADER.match(line)\n        if match:\n            # If we already have a record in progress, finalize it\n            if current_record:\n                records.append(current_record)\n            current_record = {}\n            current_record[\"record_number\"] = match.group(1)\n            current_record[\"title\"] = match.group(2)\n            continue\n\n        # Otherwise, if line looks like \"SomeKey: SomeValue\"\n        if \":\" in line:\n            parts = line.split(\":\", 1)\n            key = parts[0].strip()\n            val = parts[1].strip()\n            kl = key.lower()\n\n            # We can store known fields in canonical keys\n            if kl.startswith(\"detail page url\"):\n                current_record[\"detail_url\"] = val\n            elif kl == \"object\":\n                current_record[\"Object\"] = val\n            elif kl == \"taxonomy\":\n                current_record[\"Taxonomy\"] = val\n            elif kl == \"element or part\":\n                current_record[\"Element or Part\"] = val\n            elif kl == \"data manager\":\n                current_record[\"Data Manager\"] = val\n            elif kl == \"date uploaded\":\n                current_record[\"Date Uploaded\"] = val\n            elif kl == \"publication status\":\n                current_record[\"Publication Status\"] = val\n            elif kl == \"rights statement\":\n                current_record[\"Rights Statement\"] = val\n            elif kl == \"cc license\":\n                current_record[\"CC License\"] = val\n\n            # Also store the raw key-value in case we need it\n            current_record[key] = val\n\n    # After the loop, if there's a record in progress, append it\n    if current_record:\n        records.append(current_record)\n\n    return records\n\ndef generate_text_for_records(records):\n    \"\"\"\n    Calls the o1-mini model (via OpenAI-like usage) to generate a multi-paragraph,\n    ~200-word description for each record, focusing on species/taxonomy and object details.\n    \"\"\"\n    if not OPENAI_API_KEY:\n        return \"Error: OPENAI_API_KEY is missing.\"\n\n    # Initialize the client\n    client = OpenAI(api_key=OPENAI_API_KEY)\n\n    # Build a user prompt that includes each record's metadata\n    user_content = [\"Below are new CT records from a MorphoSource release:\\n\"]\n    if len(records) == 1:\n        user_content.append(\"There is 1 new record:\")\n    else:\n        user_content.append(f\"There are {len(records)} new records:\")\n\n    for rec in records:\n        record_num = rec.get(\"record_number\", \"N/A\")\n        user_content.append(f\"Record #{record_num}:\")\n        user_content.append(f\" - Title: {rec.get('title','N/A')}\")\n        user_content.append(f\" - URL: {rec.get('detail_url','N/A')}\")\n\n        for field in [\n            \"Object\",\n            \"Taxonomy\",\n            \"Element or Part\",\n            \"Data Manager\",\n            \"Date Uploaded\",\n            \"Publication Status\",\n            \"Rights Statement\",\n            \"CC License\",\n        ]:\n            if field in rec:\n                user_content.append(f\" - {field}: {rec[field]}\")\n        user_content.append(\"\")  # Blank line separator\n\n    # Add instructions for a ~200-word multi-paragraph summary\n    user_content.append(\n        \"You are a scientific writer with expertise in analyzing morphological data. \"\n        \"You have received metadata from X-ray computed tomography scans of various biological specimens. \"\n        \"Please compose a multi-paragraph, one for each record/species, ~200-word plain-English description that \"\n        \"emphasizes each specimen's species (taxonomy) and object details. Focus on identifying notable anatomical \"\n        \"or morphological features that may be revealed by the CT scanning process. Avoid discussions of copyright \"\n        \"or publication status. Make the final description readable for a broad audience, yet scientifically informed. \"\n        \"Highlight the significance of the scans for understanding the organism's structure and potential insights \"\n        \"into its biology or evolution. If a record lacks essential details like species name or object description, \"\n        \"include a brief note indicating the incomplete information.\"\n    )\n\n    try:\n        resp = client.chat.completions.create(\n            model=\"o1-mini\",\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\n                            \"type\": \"text\",\n                            \"text\": \"\\n\".join(user_content)\n                        }\n                    ]\n                }\n            ]\n        )\n        return resp.choices[0].message.content.strip()\n    except Exception as e:\n        return f\"Error calling o1-mini model: {e}\"\n\ndef main():\n    \"\"\"\n    1. Reads a single argument <release_body_file>\n    2. Parses it for \"New Record #...\" blocks\n    3. Calls generate_text_for_records(records) to produce a multi-paragraph text\n    4. Prints the final text to stdout\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: ct_to_text.py <release_body_file>\")\n        sys.exit(1)\n\n    release_body_file = sys.argv[1]\n    if not os.path.isfile(release_body_file):\n        print(f\"File '{release_body_file}' not found.\")\n        sys.exit(1)\n\n    with open(release_body_file, \"r\", encoding=\"utf-8\") as f:\n        body = f.read()\n\n    # Parse records\n    records = parse_records_from_body(body)\n    # Generate final text using the o1-mini model\n    description = generate_text_for_records(records)\n    print(description)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n```yaml:.github/workflows/ct_to_text.yml\nname: CT to Text\n\non:\n  workflow_run:\n    # Must match the 'name:' from your parse_morphosource_data.yml\n    workflows: [\"Parse MorphoSource Data\"]\n    types: [completed]\n\njobs:\n  ct_text_job:\n    runs-on: ubuntu-latest\n    if: ${{ github.event.workflow_run.conclusion == 'success' }}\n\n    steps:\n      # -------------------------------------------------------\n      # 1. Check out your repository\n      # -------------------------------------------------------\n      - name: Check out repo\n        uses: actions/checkout@v3\n\n      # -------------------------------------------------------\n      # 2. Set up Python\n      # -------------------------------------------------------\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.9\"\n\n      # -------------------------------------------------------\n      # 3. Install Dependencies\n      # -------------------------------------------------------\n      - name: Install Dependencies\n        run: pip install requests beautifulsoup4 openai\n\n      # -------------------------------------------------------\n      # 4. Fetch Latest Release (multi-line safe)\n      # -------------------------------------------------------\n      - name: Fetch Latest Release\n        id: fetch_release\n        env:\n          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}\n        run: |\n          echo \"Fetching the latest release from this repo...\"\n          response=$(curl -sSL -H \"Authorization: Bearer $GITHUB_TOKEN\" \\\n            https://api.github.com/repos/${{ github.repository }}/releases/latest)\n\n          # (Optional) Save JSON for debugging\n          echo \"$response\" > latest_release.json\n\n          # Extract fields\n          body=$(echo \"$response\" | python -c \"import sys, json; print(json.load(sys.stdin)['body'])\")\n          tag_name=$(echo \"$response\" | python -c \"import sys, json; print(json.load(sys.stdin)['tag_name'])\")\n\n          echo \"Found release tag_name=$tag_name\"\n\n          # Store them as outputs for subsequent steps\n          # Use multi-line safe approach for release_body\n          echo \"release_body<<EOF\" >> \"$GITHUB_OUTPUT\"\n          echo \"$body\" >> \"$GITHUB_OUTPUT\"\n          echo \"EOF\" >> \"$GITHUB_OUTPUT\"\n\n          # tag_name should be a single line\n          echo \"release_tag=$tag_name\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 5. Check if morphosource-updates\n      # -------------------------------------------------------\n      - name: Check if morphosource-updates\n        id: check_morpho\n        run: |\n          TAG_NAME=\"${{ steps.fetch_release.outputs.release_tag }}\"\n          echo \"Found TAG_NAME=$TAG_NAME\"\n\n          if [[ \"$TAG_NAME\" == morphosource-updates-* ]]; then\n            echo \"is_morphosource=true\" >> \"$GITHUB_OUTPUT\"\n          else\n            echo \"is_morphosource=false\" >> \"$GITHUB_OUTPUT\"\n          fi\n\n      # -------------------------------------------------------\n      # 6. Generate Timestamp (Only if it's morphosource-updates)\n      # -------------------------------------------------------\n      - name: Generate Timestamp\n        id: gen_ts\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        run: |\n          # Example format: YYYY-MM-DD_HH-MM-SS\n          TS=$(date +'%Y-%m-%d_%H-%M-%S')\n          echo \"timestamp=$TS\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 7. Run CT to Text (Only if it's morphosource-updates)\n      # -------------------------------------------------------\n      - name: Run CT to Text\n        id: ct2text\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        env:\n          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}\n        run: |\n          # Write the release body to a file\n          echo \"${{ steps.fetch_release.outputs.release_body }}\" > release_body.txt\n\n          # Run your custom Python script\n          python .github/scripts/ct_to_text.py release_body.txt > ct_output.txt\n\n          # Export the script output (multi-line safe)\n          echo \"description<<EOF\" >> \"$GITHUB_OUTPUT\"\n          cat ct_output.txt >> \"$GITHUB_OUTPUT\"\n          echo \"EOF\" >> \"$GITHUB_OUTPUT\"\n\n      # -------------------------------------------------------\n      # 8. Create or Update Release with AI Summary\n      # -------------------------------------------------------\n      - name: Create or Update Release with AI Summary\n        if: steps.check_morpho.outputs.is_morphosource == 'true'\n        uses: actions/create-release@v1\n        env:\n          GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}\n        with:\n          tag_name: \"ct_to_text_analysis-${{ steps.gen_ts.outputs.timestamp }}\"\n          release_name: \"CT to Text Analysis #${{ steps.gen_ts.outputs.timestamp }}\"\n          body: ${{ steps.ct2text.outputs.description }}\n          draft: false\n          prerelease: false\n\n      # -------------------------------------------------------\n      # 9. Fallback step if not morphosource-updates\n      # -------------------------------------------------------\n      - name: No new morphosource release\n        if: steps.check_morpho.outputs.is_morphosource == 'false'\n        run: echo \"No 'morphosource-updates-*' release found. Skipping CT-to-text analysis.\"\n```"
}