name: GitHub Pages Content Generation

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour
  workflow_dispatch:  # Allows manual trigger

permissions:
  contents: write

# Allow only one concurrent content generation
concurrency:
  group: "content-gen"
  cancel-in-progress: false

env:
  MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
  COMMENT_API_TOKEN: ${{ secrets.COMMENT_API_TOKEN }}
  DEBUG_LEVEL: "info"  # Can be set to debug, info, warning, error, critical

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git operations
      
      - name: Identify Workflow Trigger
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "This is a manual workflow run triggered by ${{ github.actor }}"
            echo "MANUAL=true" >> $GITHUB_ENV
            echo "DEBUG_LEVEL=debug" >> $GITHUB_ENV
            echo "::notice title=Manual Trigger::GitHub Pages update manually triggered by ${{ github.actor }}"
          else
            echo "This is a scheduled workflow run"
            echo "MANUAL=false" >> $GITHUB_ENV
            echo "::notice title=Scheduled Trigger::GitHub Pages update triggered by schedule"
          fi
          echo "GITHUB_PAGES_UPDATE_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          echo "::notice title=Generation Start::GitHub Pages content generation started at $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 markdown jinja2
          sudo apt-get update && sudo apt-get install -y jq
          
          # Create scripts directory if it doesn't exist
          mkdir -p .github/workflows/scripts
          chmod +x .github/workflows/scripts/pages-debug.py
          
          echo "::notice title=Dependencies::All dependencies installed successfully"
      
      - name: Setup Debug Mode
        run: |
          if [[ "$DEBUG_LEVEL" == "debug" ]]; then
            echo "::notice title=Debug Mode::Running in debug mode with verbose logging"
            echo "VERBOSE_FLAG=--verbose" >> $GITHUB_ENV
          else
            echo "VERBOSE_FLAG=" >> $GITHUB_ENV
          fi
          
      - name: Pre-Generation Debug Report
        run: |
          echo "::group::Pre-Generation Debug Info"
          python .github/workflows/scripts/pages-debug.py $VERBOSE_FLAG --check-branches
          echo "::endgroup::"
          
          # Create artifact directory for logs
          mkdir -p debug_logs
          cp github-pages-debug.log debug_logs/pre-generation-debug.log
          
          echo "::notice title=Pre-Generation Debug::Debug report generated before content creation"
          
      - name: Generate GitHub Pages Content
        id: generate-content
        run: |
          mkdir -p docs/assets/css
          mkdir -p docs/assets/js
          
          # Create CSS file for styling
          cat > docs/assets/css/style.css << 'EOL'
          body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
          }
          
          h1, h2, h3 {
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
          }
          
          .release-card {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
            background-color: #f6f8fa;
          }
          
          .release-card h3, .release-card h4 {
            margin-top: 0;
            border-bottom: none;
          }
          
          .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
          }
          
          .stat-card {
            flex: 1;
            min-width: 150px;
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            text-align: center;
          }
          
          .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0366d6;
          }
          
          .release-group {
            margin-bottom: 30px;
          }
          
          table.releases-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
          }
          
          table.releases-table, table.releases-table th, table.releases-table td {
            border: 1px solid #e1e4e8;
          }
          
          table.releases-table th, table.releases-table td {
            padding: 8px 12px;
            text-align: left;
          }
          
          table.releases-table th {
            background-color: #f6f8fa;
            font-weight: 600;
          }
          
          table.releases-table tr:nth-child(even) {
            background-color: #f6f8fa;
          }
          
          table.releases-table tr:hover {
            background-color: #f1f8ff;
          }
          
          /* GitHub-style contribution graph/heatmap */
          .contribution-graph {
            margin: 20px 0 30px 0;
            overflow-x: auto;
          }
          
          .contribution-graph h3 {
            margin-bottom: 10px;
          }
          
          .graph-container {
            min-height: 170px;
            padding-bottom: 10px;
          }
          
          .calendar-heatmap {
            display: inline-block;
          }
          
          .calendar-heatmap-month {
            display: inline-block;
            vertical-align: top;
            margin-right: 5px;
            margin-bottom: 5px;
          }
          
          .calendar-heatmap-month-label {
            font-size: 11px;
            color: #767676;
            text-align: center;
            margin-bottom: 2px;
          }
          
          .calendar-heatmap-day {
            width: 12px;
            height: 12px;
            margin: 1px;
            border-radius: 2px;
            background-color: #ebedf0;
            display: block;
          }
          
          .calendar-heatmap-day[data-level="0"] { background-color: #ebedf0; }
          .calendar-heatmap-day[data-level="1"] { background-color: #9be9a8; }
          .calendar-heatmap-day[data-level="2"] { background-color: #40c463; }
          .calendar-heatmap-day[data-level="3"] { background-color: #30a14e; }
          .calendar-heatmap-day[data-level="4"] { background-color: #216e39; }
          
          .heatmap-legend {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            font-size: 12px;
            color: #586069;
          }
          
          .heatmap-legend-item {
            display: inline-flex;
            align-items: center;
            margin: 0 5px;
          }
          
          .heatmap-legend-square {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 4px;
          }
          
          .tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            white-space: nowrap;
          }
          
          .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eaecef;
            text-align: center;
            font-size: 12px;
            color: #6a737d;
          }
          EOL
          
          # Create gallery CSS file
          cat > docs/assets/css/gallery.css << 'EOL'
          /* Gallery page styles */
          .gallery-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px 0;
          }
          
          .gallery-item {
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 40px;
            overflow: hidden;
          }
          
          .gallery-header {
            padding: 16px;
            border-bottom: 1px solid #eee;
          }
          
          .gallery-header h2 {
            margin: 0;
            font-size: 18px;
            border-bottom: none;
          }
          
          .gallery-header h3 {
            margin: 4px 0 0;
            font-size: 14px;
            font-weight: normal;
            color: #666;
            border-bottom: none;
          }
          
          .image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 4px;
            background-color: #f8f8f8;
          }
          
          .image-item {
            position: relative;
            padding-bottom: 100%;
            overflow: hidden;
          }
          
          .image-item img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
          }
          
          .image-item img:hover {
            transform: scale(1.05);
          }
          
          .release-description {
            padding: 16px;
            background-color: #fff;
            border-top: 1px solid #eee;
          }
          
          .description-text {
            white-space: pre-wrap;
            line-height: 1.6;
            overflow-wrap: break-word;
            font-size: 14px;
            padding: 0 10px;
            max-height: none;
            color: #333;
          }
          
          .description-text h1, .description-text h2, .description-text h3 {
            margin-top: 16px;
            margin-bottom: 8px;
            border-bottom: none;
          }
          
          .description-text ul, .description-text ol {
            padding-left: 20px;
            margin: 8px 0;
          }
          
          .timeline-separator {
            height: 60px;
            position: relative;
          }
          
          .timeline-separator:after {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            height: 100%;
            width: 2px;
            background-color: #ddd;
            transform: translateX(-50%);
          }
          
          /* Rating and comments styles */
          .rating-container {
            padding: 16px;
            border-top: 1px solid #eee;
            background-color: #f9f9f9;
          }
          
          .star-rating {
            display: flex;
            align-items: center;
            margin-bottom: 12px;
          }
          
          .rating-label {
            font-weight: bold;
            margin-right: 10px;
          }
          
          .stars {
            display: flex;
          }
          
          .star {
            color: #ddd;
            font-size: 24px;
            cursor: pointer;
            transition: color 0.2s;
          }
          
          .star:hover, .star.hover {
            color: #FFD700;
          }
          
          .star.active {
            color: #FFD700;
          }
          
          .comments-section {
            margin-top: 16px;
          }
          
          .comment-form {
            margin-bottom: 16px;
          }
          
          .comment-form textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            min-height: 80px;
            margin-bottom: 8px;
          }
          
          .comment-form button {
            background-color: #0366d6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
          }
          
          .comment-form button:hover {
            background-color: #0255b3;
          }
          
          .comment-list {
            border-top: 1px solid #eee;
            padding-top: 16px;
          }
          
          .comment {
            padding: 12px;
            border-bottom: 1px solid #eee;
          }
          
          .comment-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 12px;
            color: #666;
          }
          
          .comment-rating {
            color: #FFD700;
          }
          
          .comment-content {
            font-size: 14px;
          }
          
          .status-message {
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
          }
          
          .status-success {
            background-color: #e6ffed;
            color: #22863a;
            border: 1px solid #22863a;
          }
          
          .status-error {
            background-color: #ffeef0;
            color: #cb2431;
            border: 1px solid #cb2431;
          }
          
          /* Pagination styles */
          .pagination-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
          }
          
          .pagination-button, .pagination-page {
            display: inline-block;
            padding: 8px 16px;
            margin: 0 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-decoration: none;
            color: #0366d6;
            background-color: #fff;
            transition: background-color 0.3s, color 0.3s;
          }
          
          .pagination-button:hover, .pagination-page:hover {
            background-color: #f1f8ff;
            border-color: #0366d6;
          }
          
          .pagination-page.current {
            background-color: #0366d6;
            color: white;
            border-color: #0366d6;
            font-weight: bold;
          }
          
          .pagination-button.disabled {
            color: #ccc;
            border-color: #eee;
            background-color: #f8f8f8;
            cursor: not-allowed;
          }
          
          /* Responsive adjustments */
          @media (max-width: 640px) {
            .image-grid {
              grid-template-columns: 1fr;
            }
            
            .pagination-container {
              gap: 8px;
              padding: 0 10px;
            }
            
            .pagination-button, .pagination-page {
              padding: 6px 12px;
              margin: 0 2px;
            }
          }
          EOL
          
          # Create gallery JS file for interactive features
          cat > docs/assets/js/gallery.js << 'EOL'
          document.addEventListener('DOMContentLoaded', function() {
            // Add image click handler for lightbox effect
            const images = document.querySelectorAll('.image-item img');
            
            images.forEach(img => {
              img.addEventListener('click', function() {
                // Create lightbox
                const lightbox = document.createElement('div');
                lightbox.className = 'lightbox';
                lightbox.style.position = 'fixed';
                lightbox.style.top = '0';
                lightbox.style.left = '0';
                lightbox.style.width = '100%';
                lightbox.style.height = '100%';
                lightbox.style.backgroundColor = 'rgba(0,0,0,0.9)';
                lightbox.style.display = 'flex';
                lightbox.style.alignItems = 'center';
                lightbox.style.justifyContent = 'center';
                lightbox.style.zIndex = '1000';
                
                // Create image element
                const fullImg = document.createElement('img');
                fullImg.src = this.src;
                fullImg.style.maxHeight = '90%';
                fullImg.style.maxWidth = '90%';
                fullImg.style.objectFit = 'contain';
                
                // Add close on click
                lightbox.addEventListener('click', function() {
                  document.body.removeChild(lightbox);
                });
                
                // Append to lightbox and body
                lightbox.appendChild(fullImg);
                document.body.appendChild(lightbox);
              });
            });
            
            // Handle star ratings
            const starContainers = document.querySelectorAll('.stars');
            starContainers.forEach(container => {
              const stars = container.querySelectorAll('.star');
              
              // Set up star hover and click behavior
              stars.forEach((star, index) => {
                star.addEventListener('mouseover', () => {
                  // Highlight stars up to current
                  for (let i = 0; i <= index; i++) {
                    stars[i].classList.add('hover');
                  }
                });
                
                star.addEventListener('mouseout', () => {
                  // Remove hover class
                  stars.forEach(s => s.classList.remove('hover'));
                });
                
                star.addEventListener('click', () => {
                  // Set active stars
                  stars.forEach((s, i) => {
                    if (i <= index) {
                      s.classList.add('active');
                    } else {
                      s.classList.remove('active');
                    }
                  });
                  
                  // Store the selected rating
                  container.setAttribute('data-rating', index + 1);
                });
              });
            });
            
            // Handle comment form submissions
            const commentForms = document.querySelectorAll('.comment-form');
            commentForms.forEach(form => {
              form.addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const galleryItem = form.closest('.gallery-item');
                const releaseId = galleryItem.getAttribute('data-release-id');
                const releaseTag = galleryItem.getAttribute('data-release-tag');
                const commentText = form.querySelector('textarea').value.trim();
                const starsContainer = galleryItem.querySelector('.stars');
                const rating = starsContainer.getAttribute('data-rating') || 0;
                const statusMessage = galleryItem.querySelector('.status-message');
                
                if (!commentText) {
                  showStatus(statusMessage, 'Please enter a comment', 'error');
                  return;
                }
                
                if (!rating || rating === '0') {
                  showStatus(statusMessage, 'Please select a rating', 'error');
                  return;
                }
                
                showStatus(statusMessage, 'Saving your feedback...', 'pending');
                
                // Create the feedback data
                const feedback = {
                  releaseId: releaseId,
                  releaseTag: releaseTag,
                  rating: parseInt(rating),
                  comment: commentText,
                  timestamp: new Date().toISOString()
                };
                
                try {
                  // Store in localStorage (as a fallback)
                  saveToLocalStorage(feedback);
                  
                  // Always try to save to GitHub repository (using preset token)
                  try {
                    const success = await saveRatingToGitHub(feedback);
                    if (success) {
                      showStatus(statusMessage, 'Thank you for your feedback! Your comment will be visible to all users.', 'success');
                    } else {
                      showStatus(statusMessage, 'Feedback saved locally only. Others won\'t see your comment.', 'success');
                    }
                  } catch (apiError) {
                    console.warn('Could not save to GitHub API:', apiError);
                    showStatus(statusMessage, 'Feedback saved locally only. Others won\'t see your comment.', 'success');
                  }
                  
                  // Reset form
                  form.reset();
                  galleryItem.querySelectorAll('.star').forEach(s => s.classList.remove('active'));
                  starsContainer.setAttribute('data-rating', '0');
                  
                  // Add comment to the display
                  addCommentToList(galleryItem, feedback);
                  
                } catch (error) {
                  console.error('Error saving feedback:', error);
                  showStatus(statusMessage, 'Error saving feedback. Please try again.', 'error');
                }
              });
            });
            
            // Load existing comments on page load - always try server first
            loadCommentsFromServer().then(() => {
              // As a fallback, also load any locally stored comments
              loadCommentsFromLocalStorage();
            }).catch(err => {
              console.warn('Error loading server comments:', err);
              // If server loading fails, make sure to load local comments
              loadCommentsFromLocalStorage();
            });
            
            // Utility function to show status messages
            function showStatus(element, message, type) {
              if (!element) return;
              
              element.textContent = message;
              element.className = 'status-message';
              
              if (type === 'success') {
                element.classList.add('status-success');
              } else if (type === 'error') {
                element.classList.add('status-error');
              }
              
              element.style.display = 'block';
              
              if (type === 'success' || type === 'error') {
                setTimeout(() => {
                  element.style.display = 'none';
                }, 5000);
              }
            }
            
            // Store in localStorage
            function saveToLocalStorage(feedback) {
              const storageKey = 'ct-feedback-all';
              const existingFeedback = JSON.parse(localStorage.getItem(storageKey) || '[]');
              existingFeedback.push(feedback);
              localStorage.setItem(storageKey, JSON.stringify(existingFeedback));
              
              // Also store by release ID for faster retrieval
              const releaseKey = `ct-feedback-${feedback.releaseId}`;
              const existingReleaseFeedback = JSON.parse(localStorage.getItem(releaseKey) || '[]');
              existingReleaseFeedback.push(feedback);
              localStorage.setItem(releaseKey, JSON.stringify(existingReleaseFeedback));
            }
            
            // Function to save rating to GitHub repository using repository_dispatch
            async function saveRatingToGitHub(feedback) {
              const owner = 'johntrue15';
              const repo = 'NOCTURN-X-ray-repo';
              
              // Use hardcoded token - this is not exposed to clients as it's replaced by workflow
              const token = '{{COMMENT_API_TOKEN}}';
              
              // Replace template with actual token by the GitHub workflow when building
              // This way no real token is in client-side code
              if (!token || token === '{{COMMENT_API_TOKEN}}') {
                console.warn('No GitHub token available for API. Using fallback method.');
                return false;
              }
              
              const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/dispatches`, {
                method: 'POST',
                headers: {
                  'Authorization': `token ${token}`,
                  'Accept': 'application/vnd.github.v3+json',
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  event_type: 'save-rating',
                  client_payload: feedback
                })
              });
              
              if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status}`);
              }
              
              return true;
            }
            
            // Function to load comments from localStorage
            function loadCommentsFromLocalStorage() {
              const galleryItems = document.querySelectorAll('.gallery-item');
              galleryItems.forEach(item => {
                const releaseId = item.getAttribute('data-release-id');
                if (!releaseId) return;
                
                const storageKey = `ct-feedback-${releaseId}`;
                const storedFeedback = JSON.parse(localStorage.getItem(storageKey) || '[]');
                
                storedFeedback.forEach(feedback => {
                  addCommentToList(item, feedback, true); // true = check for duplicates
                });
              });
            }
            
            // Function to load comments from the server (ratings.json)
            async function loadCommentsFromServer() {
              // Cache-busting query parameter to ensure we always get latest data
              const cacheBuster = Date.now();
              const response = await fetch(`/assets/data/ratings.json?_=${cacheBuster}`);
              
              if (!response.ok) {
                console.warn('Could not load ratings from server:', response.status);
                return;
              }
              
              const data = await response.json();
              if (!data || !data.ratings || !Array.isArray(data.ratings)) {
                console.warn('Invalid ratings data format');
                return;
              }
              
              console.log(`Loaded ${data.ratings.length} ratings from server`);
              
              // Process each rating
              const galleryItems = document.querySelectorAll('.gallery-item');
              galleryItems.forEach(item => {
                const releaseId = item.getAttribute('data-release-id');
                if (!releaseId) return;
                
                // Find ratings for this release
                const releaseRatings = data.ratings.filter(r => r.releaseId === releaseId);
                
                releaseRatings.forEach(feedback => {
                  addCommentToList(item, feedback, true); // true = check for duplicates
                });
              });
              
              return data.ratings.length;
            }
            
            // Function to add a comment to the UI
            function addCommentToList(galleryItem, feedback, checkDuplicates = false) {
              const commentList = galleryItem.querySelector('.comment-list');
              if (!commentList) return;
              
              // Check for duplicates if requested
              if (checkDuplicates) {
                const commentDate = new Date(feedback.timestamp).toLocaleString();
                const commentExists = Array.from(commentList.querySelectorAll('.comment')).some(comment => {
                  const existingDate = comment.querySelector('.comment-date').textContent;
                  const existingContent = comment.querySelector('.comment-content').textContent;
                  
                  return existingDate === commentDate && existingContent === feedback.comment;
                });
                
                if (commentExists) return; // Skip if duplicate
              }
              
              const commentElement = document.createElement('div');
              commentElement.className = 'comment';
              
              const starIcons = '★'.repeat(feedback.rating) + '☆'.repeat(5 - feedback.rating);
              
              commentElement.innerHTML = `
                <div class="comment-header">
                  <span class="comment-date">${new Date(feedback.timestamp).toLocaleString()}</span>
                  <span class="comment-rating">${starIcons}</span>
                </div>
                <div class="comment-content">${feedback.comment}</div>
              `;
              
              commentList.appendChild(commentElement);
            }
            
            // Lazy loading for images
            if ('IntersectionObserver' in window) {
              const lazyImages = document.querySelectorAll('img[loading="lazy"]');
              const imageObserver = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                  if (entry.isIntersecting) {
                    const img = entry.target;
                    img.src = img.dataset.src || img.src;
                    imageObserver.unobserve(img);
                  }
                });
              });
              
              lazyImages.forEach(img => {
                imageObserver.observe(img);
              });
            }
          });
          EOL
          
          # Create JS file for interactive features
          cat > docs/assets/js/main.js << 'EOL'
          document.addEventListener('DOMContentLoaded', function() {
            // Add any interactive features here
            console.log('GitHub Pages for NOCTURN X-ray loaded');
            
            // Add click event to expandable sections if needed
            const expandButtons = document.querySelectorAll('.expand-button');
            expandButtons.forEach(button => {
              button.addEventListener('click', function() {
                const content = this.nextElementSibling;
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
                this.textContent = content.style.display === 'none' ? 'Show Details' : 'Hide Details';
              });
            });
            
            // Initialize the contribution graph
            initializeHeatmap();
          });
          
          function initializeHeatmap() {
            const container = document.getElementById('contribution-graph');
            if (!container) return;
            
            // Get the data from the hidden element
            const dataElement = document.getElementById('heatmap-data');
            if (!dataElement) return;
            
            try {
              // Parse the JSON data
              const heatmapData = JSON.parse(dataElement.textContent);
              
              // Render the heatmap
              renderCalendarHeatmap(container, heatmapData);
              
              // Setup the tooltip
              setupHeatmapTooltips();
            } catch (error) {
              console.error('Error initializing heatmap:', error);
              container.innerHTML = '<p>Error loading contribution data</p>';
            }
          }
          
          function renderCalendarHeatmap(container, data) {
            // Get all unique months in the data
            const months = [];
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Group data by month
            const monthsData = {};
            
            // Process each day's data
            for (const date in data) {
              const dateObj = new Date(date);
              const month = dateObj.getMonth();
              const year = dateObj.getFullYear();
              const monthKey = `${year}-${month}`;
              
              if (!monthsData[monthKey]) {
                monthsData[monthKey] = {
                  year,
                  month,
                  days: {}
                };
                months.push(monthKey);
              }
              
              monthsData[monthKey].days[dateObj.getDate()] = data[date];
            }
            
            // Sort months chronologically
            months.sort();
            
            // Create the calendar heatmap
            const heatmapHTML = document.createElement('div');
            heatmapHTML.className = 'calendar-heatmap';
            
            // Create each month's block
            months.forEach(monthKey => {
              const monthData = monthsData[monthKey];
              const monthBlock = document.createElement('div');
              monthBlock.className = 'calendar-heatmap-month';
              
              // Add month label
              const monthLabel = document.createElement('div');
              monthLabel.className = 'calendar-heatmap-month-label';
              monthLabel.textContent = monthNames[monthData.month];
              monthBlock.appendChild(monthLabel);
              
              // Calculate days in month
              const daysInMonth = new Date(monthData.year, monthData.month + 1, 0).getDate();
              
              // Add each day as a square
              for (let day = 1; day <= daysInMonth; day++) {
                const daySquare = document.createElement('div');
                daySquare.className = 'calendar-heatmap-day';
                
                const count = monthData.days[day] || 0;
                let level = 0;
                
                // Set color level based on count
                if (count > 0) {
                  if (count === 1) level = 1;
                  else if (count <= 3) level = 2;
                  else if (count <= 6) level = 3;
                  else level = 4;
                }
                
                daySquare.setAttribute('data-level', level);
                daySquare.setAttribute('data-date', `${monthData.year}-${monthData.month+1}-${day}`);
                daySquare.setAttribute('data-count', count);
                
                monthBlock.appendChild(daySquare);
              }
              
              heatmapHTML.appendChild(monthBlock);
            });
            
            // Clear container and add the heatmap
            container.innerHTML = '';
            container.appendChild(heatmapHTML);
            
            // Add legend
            const legend = document.createElement('div');
            legend.className = 'heatmap-legend';
            legend.innerHTML = `
              <div class="heatmap-legend-item">
                <div class="heatmap-legend-square" style="background-color: #ebedf0;"></div>
                <span>No updates</span>
              </div>
              <div class="heatmap-legend-item">
                <div class="heatmap-legend-square" style="background-color: #9be9a8;"></div>
                <span>1 update</span>
              </div>
              <div class="heatmap-legend-item">
                <div class="heatmap-legend-square" style="background-color: #40c463;"></div>
                <span>2-3 updates</span>
              </div>
              <div class="heatmap-legend-item">
                <div class="heatmap-legend-square" style="background-color: #30a14e;"></div>
                <span>4-6 updates</span>
              </div>
              <div class="heatmap-legend-item">
                <div class="heatmap-legend-square" style="background-color: #216e39;"></div>
                <span>7+ updates</span>
              </div>
            `;
            
            container.appendChild(legend);
          }
          
          function setupHeatmapTooltips() {
            const squares = document.querySelectorAll('.calendar-heatmap-day');
            let tooltip = null;
            
            squares.forEach(square => {
              square.addEventListener('mouseover', function(event) {
                const date = this.getAttribute('data-date');
                const count = this.getAttribute('data-count');
                
                if (!tooltip) {
                  tooltip = document.createElement('div');
                  tooltip.className = 'tooltip';
                  document.body.appendChild(tooltip);
                }
                
                // Format date 
                const formattedDate = new Date(date).toLocaleDateString(undefined, { 
                  weekday: 'long', 
                  year: 'numeric', 
                  month: 'long', 
                  day: 'numeric' 
                });
                
                tooltip.innerHTML = `${formattedDate}: ${count} update${count !== '1' ? 's' : ''}`;
                
                const rect = this.getBoundingClientRect();
                tooltip.style.top = `${rect.top - 30 + window.scrollY}px`;
                tooltip.style.left = `${rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2)}px`;
                tooltip.style.display = 'block';
              });
              
              square.addEventListener('mouseout', function() {
                if (tooltip) {
                  tooltip.style.display = 'none';
                }
              });
            });
          }
          EOL
          
          # Create directory for storing ratings data
          mkdir -p docs/assets/data
          
          # Create initial empty ratings.json file
          cat > docs/assets/data/ratings.json << 'EOL'
          {
            "ratings": []
          }
          EOL
          
          # Generate the index.md file with release information
          python - << 'EOL'
          import os
          import json
          import glob
          import logging
          import re
          import subprocess
          from datetime import datetime
          from collections import defaultdict
          import markdown
          
          # Setup logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(),
                  logging.FileHandler('content_generation.log')
              ]
          )
          logger = logging.getLogger('content-generator')
          
          if os.environ.get('DEBUG_LEVEL') == 'debug':
              logger.setLevel(logging.DEBUG)
          
          def get_github_releases():
              """Get all GitHub releases using git command"""
              logger.info("Fetching GitHub releases")
              
              try:
                  # Fetch all tags
                  subprocess.run(["git", "fetch", "--tags"], check=True)
                  
                  # Get all tags
                  result = subprocess.run(
                      ["git", "tag", "-l"], 
                      capture_output=True, 
                      text=True, 
                      check=True
                  )
                  tags = result.stdout.strip().split('\n')
                  logger.info(f"Found {len(tags)} tags")
                  
                  # Process each tag
                  releases = []
                  release_types = defaultdict(int)
                  
                  for tag in tags:
                      if not tag:
                          continue
                      
                      # Extract release type and date from tag
                      release_type = None
                      date = None
                      
                      # Pattern matching for different release types
                      patterns = [
                          (r'(ct_to_text_analysis|ct-to-text-analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT to Text Analysis'),
                          (r'(daily-check|daily_check)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Daily Check'),
                          (r'(daily)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Daily'),
                          (r'(morphosource-updates|morphosource_updates)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Updates'),
                          (r'(morphosource-modified|morphosource_modified)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Modified'),
                          (r'(morphosource-check)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Check'),
                          (r'(ct-image-analysis|ct_image_analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT Image Analysis'),
                          (r'(ct-slice-analysis|ct_slice_analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT Slice Analysis'),
                          (r'(monthly-collection)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Monthly Collection'),
                          (r'(ct_analysis_error)-(\d+)', 'CT Analysis Error'),
                      ]
                      
                      for pattern, type_name in patterns:
                          match = re.search(pattern, tag, re.IGNORECASE)
                          if match:
                              release_type = type_name
                              date = match.group(2)
                              break
                      
                      # Skip releases that don't match our patterns
                      if not release_type or not date:
                          logger.debug(f"Skipping tag {tag} - doesn't match any known release pattern")
                          continue
                      
                      # Get release description
                      try:
                          result = subprocess.run(
                              ["git", "tag", "-l", "-n999", tag], 
                              capture_output=True, 
                              text=True, 
                              check=True
                          )
                          description = result.stdout.strip()
                          # Remove the tag name from the beginning of the description
                          if description.startswith(tag):
                              description = description[len(tag):].strip()
                      except subprocess.CalledProcessError:
                          description = "No description available"
                      
                      # Format date for display (if it's a date-based tag)
                      display_date = date
                      if re.match(r'\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}', date):
                          # Split into date and time parts
                          date_part, time_part = date.split('_')
                          # Format date as YYYY/MM/DD and time as HH:MM:SS UTC
                          display_date = date_part.replace('-', '/') + ' ' + time_part.replace('-', ':') + ' UTC'
                      
                      # Extract image URLs for CT Image Analysis releases
                      image_urls = []
                      if release_type == 'CT Image Analysis':
                          # For CT Image Analysis releases, try to extract images from release assets
                          # Get release assets using GitHub API
                          try:
                              if os.environ.get('MY_GITHUB_TOKEN'):
                                  import requests
                                  
                                  # Use GitHub API to get release by tag
                                  headers = {"Authorization": f"token {os.environ.get('MY_GITHUB_TOKEN')}"}
                                  repo = os.environ.get('GITHUB_REPOSITORY', 'johntrue15/NOCTURN-X-ray-repo')
                                  api_url = f"https://api.github.com/repos/{repo}/releases/tags/{tag}"
                                  
                                  logger.info(f"Fetching assets for release {tag} from {api_url}")
                                  response = requests.get(api_url, headers=headers)
                                  
                                  if response.status_code == 200:
                                      release_data = response.json()
                                      
                                      # Get assets
                                      if 'assets' in release_data and release_data['assets']:
                                          logger.info(f"Found {len(release_data['assets'])} assets for release {tag}")
                                          
                                          # Priority order for orientation view images
                                          orientation_images = [
                                              "Default_Yplus_Up.png",
                                              "Upside_Down_Y-_Up.png", 
                                              "Forward_90_Z-_Up.png",
                                              "Back_90_Zplus_Up.png"
                                          ]
                                          
                                          # Find orientation view images first
                                          found_images = {}
                                          for asset in release_data['assets']:
                                              asset_name = asset.get('name', '')
                                              if asset_name in orientation_images:
                                                  found_images[asset_name] = asset.get('browser_download_url')
                                          
                                          # Add orientation images in specific order
                                          for img_name in orientation_images:
                                              if img_name in found_images:
                                                  image_urls.append(found_images[img_name])
                                          
                                          # If we don't have enough orientation images, look for any other PNG files
                                          if len(image_urls) < 4:
                                              for asset in release_data['assets']:
                                                  asset_name = asset.get('name', '')
                                                  if asset_name.lower().endswith('.png') and asset_name not in orientation_images:
                                                      image_urls.append(asset.get('browser_download_url'))
                                                      if len(image_urls) >= 4:
                                                          break
                                          
                                          # Use the full release body text from the API response instead of git tag description
                                          if 'body' in release_data and release_data['body']:
                                              # Replace the git tag description with the actual release body
                                              description = release_data['body']
                                              # Process the description to handle Markdown formatting
                                              try:
                                                  # Convert Markdown to HTML for better rendering
                                                  description = markdown.markdown(description)
                                              except Exception as e:
                                                  logger.warning(f"Error converting markdown to HTML: {str(e)}")
                                              logger.info(f"Using full release body from GitHub API for {tag}")
                          except Exception as e:
                              logger.error(f"Error fetching release assets: {str(e)}")
                          
                          # If no images found from assets, try searching in the description
                          if not image_urls:
                              # Look for image links in the description
                              img_matches = re.findall(r'!\[.*?\]\((.*?)\)', description)
                              for img_url in img_matches:
                                  image_urls.append(img_url)
                              
                              # If no images found with markdown syntax, try searching for URLs that look like images
                              if not image_urls:
                                  url_matches = re.findall(r'https?://\S+\.(jpg|jpeg|png|gif|webp)', description, re.IGNORECASE)
                                  for url in url_matches:
                                      image_urls.append(url)
                          
                          # If still no images found, add placeholder URLs for demo
                          if not image_urls:
                              # Add placeholder images for demonstration
                              image_urls = [
                                  f"https://via.placeholder.com/800x600.png?text=Default+(Y%2B+Up)",
                                  f"https://via.placeholder.com/800x600.png?text=Upside+Down+(Y-+Up)",
                                  f"https://via.placeholder.com/800x600.png?text=Forward+90°+(Z-+Up)",
                                  f"https://via.placeholder.com/800x600.png?text=Back+90°+(Z%2B+Up)"
                              ]
                      
                      release_info = {
                          'tag': tag,
                          'type': release_type,
                          'date': date,
                          'display_date': display_date,
                          'description': description,
                          'image_urls': image_urls
                      }
                      
                      releases.append(release_info)
                      release_types[release_type] += 1
                      
                  # Define a custom sorting function to handle different tag formats
                  def sort_key(x):
                      if re.match(r'\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}', x['date']):
                          # For date-based tags, convert to a timestamp for sorting
                          return x['date']
                      elif x['date'].isdigit():
                          # For numeric ID tags, pad with zeros for proper sorting
                          return f"{int(x['date']):020d}"
                      else:
                          # Default fallback
                          return x['date']
                          
                  # Sort releases (newest first)
                  releases.sort(key=sort_key, reverse=True)
                  logger.info(f"Processed {len(releases)} releases")
                  
                  return releases, release_types
                  
              except subprocess.CalledProcessError as e:
                  logger.error(f"Error getting GitHub releases: {e}")
                  return [], {}
                  
              except Exception as e:
                  logger.error(f"Unexpected error getting GitHub releases: {e}")
                  return [], {}
          
          def get_latest_releases(data_dir='data', limit=10):
              """Get data from filesystem-based releases (legacy method)"""
              logger.info(f"Searching for legacy release data in {data_dir}")
              # Find all date-based directories
              date_dirs = glob.glob(os.path.join(data_dir, '20*-*-*_*-*-*'))
              
              if not date_dirs:
                  logger.warning(f"No release directories found in {data_dir}")
                  return []
              
              # Sort directories by name (which contains the date)
              date_dirs.sort(reverse=True)
              logger.info(f"Found {len(date_dirs)} release directories, using up to {limit}")
              
              releases = []
              for dir_path in date_dirs[:limit]:
                  logger.debug(f"Processing directory: {dir_path}")
                  release_notes_path = os.path.join(dir_path, 'release_notes.txt')
                  daily_info_path = os.path.join(dir_path, 'daily_info.json')
                  
                  if os.path.exists(release_notes_path):
                      logger.debug(f"Found release notes: {release_notes_path}")
                      with open(release_notes_path, 'r') as f:
                          notes_content = f.read()
                      
                      # Extract date from directory name
                      dir_name = os.path.basename(dir_path)
                      date_str = dir_name.split('_')[0].replace('-', '/')
                      
                      release_info = {
                          'date': date_str,
                          'path': dir_path,
                          'notes': notes_content,
                          'type': 'Daily Check'  # Default to Daily Check for legacy releases
                      }
                      
                      # Add extra info from daily_info.json if available
                      if os.path.exists(daily_info_path):
                          try:
                              logger.debug(f"Found daily info: {daily_info_path}")
                              with open(daily_info_path, 'r') as f:
                                  daily_info = json.load(f)
                              release_info['daily_info'] = daily_info
                          except Exception as e:
                              logger.error(f"Error loading {daily_info_path}: {e}")
                      
                      releases.append(release_info)
                  else:
                      logger.warning(f"No release_notes.txt found in {dir_path}")
              
              logger.info(f"Processed {len(releases)} release directories successfully")
              return releases
          
          def generate_index_md(github_releases, release_types, legacy_releases=[]):
              """Generate the index.md content with all releases organized by type"""
              logger.info("Generating index.md content")
              # Get the timestamp from environment variable
              update_timestamp = os.environ.get('GITHUB_PAGES_UPDATE_TIMESTAMP', datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC'))
              
              # Generate contribution heatmap data for MorphoSource updates
              morphosource_releases = [r for r in github_releases if r['type'] in ['MorphoSource Updates', 'MorphoSource Modified', 'MorphoSource Check']]
              
              # Create a dictionary to count releases by date
              heatmap_data = {}
              
              # Process each release to extract date information
              for release in morphosource_releases:
                  # Extract date from release
                  if re.match(r'\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}', release['date']):
                      # Format is YYYY-MM-DD_HH-MM-SS
                      date_only = release['date'].split('_')[0]  # Get just the date part
                      
                      # Add to counts
                      if date_only in heatmap_data:
                          heatmap_data[date_only] += 1
                      else:
                          heatmap_data[date_only] = 1
              
              # Convert heatmap data to JSON for JavaScript processing
              import json
              heatmap_json = json.dumps(heatmap_data)
              
              # Start building the content
              content = f"""# NOCTURN X-ray Release Information

          This page displays information about the latest data releases for the NOCTURN X-ray project.

          **Last Updated:** {update_timestamp}

          ## Summary Statistics

          <div class="stats-container">
              <div class="stat-card">
                  <div>Total Releases</div>
                  <div class="stat-value">{len(github_releases)}</div>
              </div>
          """
              
              # Add stats for each release type
              for release_type, count in release_types.items():
                  content += f"""    <div class="stat-card">
                  <div>{release_type}</div>
                  <div class="stat-value">{count}</div>
              </div>
          """
              
              # Close the stats container
              content += """</div>

          ## MorphoSource Updates Over Time

          <div class="contribution-graph">
              <h3>Update Activity</h3>
              <div id="contribution-graph" class="graph-container">
                  <!-- The heatmap will be generated here by JavaScript -->
                  <p>Loading contribution data...</p>
              </div>
          </div>

          <!-- Hidden element containing heatmap data -->
          <script id="heatmap-data" type="application/json">
          """ + heatmap_json + """
          </script>

          ## Releases by Type

          <table class="releases-table">
              <tr>
                  <th>Type</th>
                  <th>Date & Time</th>
                  <th>Tag</th>
              </tr>
          """
              
              # Add rows for each release
              for release in github_releases[:50]:  # Limit to 50 most recent
                  content += f"""    <tr>
                  <td>{release['type']}</td>
                  <td>{release['display_date']}</td>
                  <td><a href="https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/{release['tag']}">{release['tag']}</a></td>
              </tr>
          """
              
              # Close the table
              content += """</table>

          ## Recent Releases by Type
          """
              
              # Group releases by type
              releases_by_type = defaultdict(list)
              for release in github_releases:
                  releases_by_type[release['type']].append(release)
              
              # Add sections for each type
              for release_type, releases in releases_by_type.items():
                  content += f"""
          ### {release_type}
          
          <div class="release-group">
          """
                  # Add up to 5 most recent releases of this type
                  for release in releases[:5]:
                      content += f"""<div class="release-card">
              <h4>{release['display_date']} - <a href="https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/{release['tag']}">{release['tag']}</a></h4>
              
              ```
              {release['description'] if len(release['description']) < 500 else release['description'][:500] + '... (truncated)'}
              ```
          </div>
          """
                  
                  content += """</div>
          """
              
              # Add link to image analysis page if CT Image Analysis releases exist
              if 'CT Image Analysis' in release_types and release_types['CT Image Analysis'] > 0:
                  content += """
          ## Specialized Views

          - [CT Image Analysis Gallery](/image_analysis.html) - View CT scan images in an Instagram-style timeline

          """
              
              # Add footer
              content += """
          ## About NOCTURN X-ray

          NOCTURN is a project designed to streamline non-clinical tomographic imaging workflows across various facilities. Each facility may require its own custom scripts or configuration, which is why we have multiple branches for separate facility requirements.

          <div class="footer">
            <p>© NOCTURN X-ray Project. Deployed via GitHub Pages.</p>
            <p>This page is automatically updated hourly with the latest release information.</p>
          </div>
          """
              
              logger.info(f"Generated index.md content ({len(content)} characters)")
              return content
          
          def generate_image_analysis_page(github_releases):
              """Generate a dedicated page for CT Image Analysis releases with Instagram-style layout"""
              logger.info("Generating image_analysis.md content")
              
              # Get CT Image Analysis releases only
              ct_image_releases = [r for r in github_releases if r['type'] == 'CT Image Analysis']
              
              if not ct_image_releases:
                  logger.warning("No CT Image Analysis releases found for gallery page")
                  return None
              
              # Get the timestamp from environment variable
              update_timestamp = os.environ.get('GITHUB_PAGES_UPDATE_TIMESTAMP', datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC'))
              
              # Define pagination settings
              items_per_page = 5  # Number of gallery items per page
              total_items = len(ct_image_releases)
              total_pages = max(1, (total_items + items_per_page - 1) // items_per_page)  # Ceiling division
              
              logger.info(f"Creating {total_pages} pages for {total_items} CT Image Analysis releases")
              
              # Generate content for each page
              all_pages_content = []
              
              for page_num in range(1, total_pages + 1):
                  # Calculate item range for this page
                  start_idx = (page_num - 1) * items_per_page
                  end_idx = min(start_idx + items_per_page, total_items)
                  page_items = ct_image_releases[start_idx:end_idx]
                  
                  # Start building the content for this page
                  content = f"""# CT Image Analysis Gallery (Page {page_num} of {total_pages})

          This page displays CT scan images from analysis releases in an Instagram-style timeline.

          **Last Updated:** {update_timestamp}

          <link rel="stylesheet" href="assets/css/gallery.css">

          <div class="gallery-container">
          """
                  
                  # Add each release as a timeline entry for this page
                  for release in page_items:
                      # Generate a unique ID for this release
                      release_id = f"release-{release['tag'].replace('.', '-').replace('_', '-')}"
                      
                      content += f"""
          <div class="gallery-item" data-release-id="{release_id}" data-release-tag="{release['tag']}">
              <div class="gallery-header">
                  <h2>{release['display_date']}</h2>
                  <h3><a href="https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/{release['tag']}">{release['tag']}</a></h3>
              </div>
              
              <div class="image-grid">
              """
                      
                      # Add images in a grid
                      for idx, img_url in enumerate(release['image_urls'][:4]):  # Limit to 4 images
                          content += f"""          <div class="image-item">
                      <img src="{img_url}" alt="CT Image {idx+1}" loading="lazy">
                  </div>
              """
                      
                      # Close the image grid
                      content += """        </div>
              
              <div class="release-description">
              """
                      
                      # Add the release description with improved formatting
                      content += f"""          <div class="description-text">
                      {release['description']}
                  </div>
              """
                      
                      # Add rating and comments section
                      content += """        </div>
                      
              <!-- Rating and Comments Section -->
              <div class="rating-container">
                  <div class="star-rating">
                      <span class="rating-label">Rate this analysis:</span>
                      <div class="stars" data-rating="0">
                          <span class="star">★</span>
                          <span class="star">★</span>
                          <span class="star">★</span>
                          <span class="star">★</span>
                          <span class="star">★</span>
                      </div>
                  </div>
                  
                  <div class="comments-section">
                      <h4>Leave a Comment</h4>
                      <form class="comment-form">
                          <textarea placeholder="Share your thoughts on this analysis..."></textarea>
                          <button type="submit">Submit</button>
                      </form>
                      <div class="status-message" style="display: none;"></div>
                      
                      <div class="comment-list">
                          <!-- Comments will be loaded here -->
                      </div>
                  </div>
              </div>
          </div>

          <div class="timeline-separator"></div>
          """
                  
                  # Add pagination navigation
                  content += """
          <div class="pagination-container">
          """
                  
                  # Add Previous button - disabled if on first page
                  if page_num == 1:
                      content += """    <span class="pagination-button disabled">Previous</span>"""
                  else:
                      prev_page_url = "image_analysis.html" if page_num == 2 else f"image_analysis_page{page_num-1}.html"
                      content += f"""    <a href="{prev_page_url}" class="pagination-button">Previous</a>"""
                  
                  # Add numbered page links
                  for i in range(1, total_pages + 1):
                      if i == page_num:
                          content += f"""    <span class="pagination-page current">{i}</span>"""
                      else:
                          page_url = "image_analysis.html" if i == 1 else f"image_analysis_page{i}.html"
                          content += f"""    <a href="{page_url}" class="pagination-page">{i}</a>"""
                  
                  # Add Next button - disabled if on last page
                  if page_num == total_pages:
                      content += """    <span class="pagination-button disabled">Next</span>"""
                  else:
                      next_page_url = f"image_analysis_page{page_num+1}.html"
                      content += f"""    <a href="{next_page_url}" class="pagination-button">Next</a>"""
                  
                  # Close pagination container
                  content += """
          </div>
          """
                  
                  # Close the gallery container
                  content += """      </div>

          <script src="assets/js/gallery.js"></script>

          <div class="footer">
            <p>© NOCTURN X-ray Project. Deployed via GitHub Pages.</p>
            <p>Return to <a href="index.html">main dashboard</a>.</p>
          </div>
          """
                  
                  # Save the content for this page
                  all_pages_content.append((page_num, content))
                  logger.info(f"Generated content for page {page_num}")
              
              # Return the first page's content and save the rest
              for page_num, content in all_pages_content:
                  if page_num == 1:
                      # First page goes to the main file
                      with open('docs/image_analysis.md', 'w') as f:
                          f.write(content)
                      
                      # Create a separate HTML file with Jekyll front matter
                      with open('docs/image_analysis.html', 'w') as f:
                          f.write("---\n")
                          f.write("layout: default\n")
                          f.write("title: CT Image Analysis Gallery\n")
                          f.write("---\n\n")
                          f.write(content)
                      
                      logger.info("Created main gallery page (image_analysis.html)")
                  else:
                      # Subsequent pages go to separate files
                      with open(f'docs/image_analysis_page{page_num}.md', 'w') as f:
                          f.write(content)
                      
                      # Create a separate HTML file with Jekyll front matter
                      with open(f'docs/image_analysis_page{page_num}.html', 'w') as f:
                          f.write("---\n")
                          f.write("layout: default\n")
                          f.write(f"title: CT Image Analysis Gallery - Page {page_num}\n")
                          f.write("---\n\n")
                          f.write(content)
                      
                      logger.info(f"Created gallery page {page_num} (image_analysis_page{page_num}.html)")
              
              return all_pages_content[0][1] if all_pages_content else None
          
          # Main execution
          try:
              logger.info("Starting content generation")
              
              # Get GitHub releases
              github_releases, release_types = get_github_releases()
              
              # Get legacy releases for backup
              legacy_releases = get_latest_releases()
              
              if github_releases:
                  # Generate content using GitHub releases
                  index_content = generate_index_md(github_releases, release_types, legacy_releases)
                  
                  with open('docs/index.md', 'w') as f:
                      f.write(index_content)
                  
                  logger.info("Successfully wrote index.md")
                  
                  # Generate the image analysis page if there are CT Image Analysis releases
                  if 'CT Image Analysis' in release_types and release_types['CT Image Analysis'] > 0:
                      image_analysis_content = generate_image_analysis_page(github_releases)
                      
                      if image_analysis_content:
                          with open('docs/image_analysis.md', 'w') as f:
                              f.write(image_analysis_content)
                          
                          # Create a separate HTML file with Jekyll front matter
                          with open('docs/image_analysis.html', 'w') as f:
                              f.write("---\n")
                              f.write("layout: default\n")
                              f.write("title: CT Image Analysis Gallery\n")
                              f.write("---\n\n")
                              f.write(image_analysis_content)
                          
                          logger.info("Successfully wrote image_analysis.md and image_analysis.html")
              elif legacy_releases:
                  # Fallback to legacy releases if no GitHub releases
                  logger.warning("No GitHub releases found, falling back to legacy releases")
                  release_types = defaultdict(int)
                  release_types['Daily Check'] = len(legacy_releases)
                  
                  # Convert legacy releases to GitHub release format
                  github_style_releases = []
                  for release in legacy_releases:
                      github_style_releases.append({
                          'tag': f"daily-check-{release['date'].replace('/', '-')}",
                          'type': 'Daily Check',
                          'date': release['date'].replace('/', '-'),
                          'display_date': release['date'],
                          'description': release['notes'][:500] if len(release['notes']) > 500 else release['notes']
                      })
                  
                  index_content = generate_index_md(github_style_releases, release_types)
                  
                  with open('docs/index.md', 'w') as f:
                      f.write(index_content)
                  
                  logger.info("Successfully wrote index.md using legacy releases")
              else:
                  logger.error("No releases found, cannot generate content")
                  
                  # Create a fallback index.md
                  with open('docs/index.md', 'w') as f:
                      f.write("""# NOCTURN X-ray Release Information

          **No release data is currently available. Please check back later.**

          This page is automatically updated hourly with the latest release information.
          """)
                  logger.info("Created fallback index.md")
          except Exception as e:
              logger.error(f"Error generating content: {e}")
              raise
          EOL
          
          # Configure Jekyll (_config.yml)
          cat > docs/_config.yml << 'EOL'
          title: NOCTURN X-ray Release Information
          description: Displaying information about the latest data releases for the NOCTURN X-ray project
          theme: jekyll-theme-cayman
          
          # GitHub Pages settings
          github:
            is_project_page: true
            repository_url: https://github.com/johntrue15/NOCTURN-X-ray-repo
          
          # Enable debugging info
          verbose: true
          EOL
          
          # Show generation log
          echo "::group::Content Generation Log"
          cat content_generation.log
          echo "::endgroup::"
          
          # Save log to debug logs directory
          cp content_generation.log debug_logs/
          
          echo "::notice title=Content Generation::GitHub Pages content generated successfully"
      
      - name: Post-Generation Debug Report
        run: |
          echo "::group::Post-Generation Debug Info"
          python .github/workflows/scripts/pages-debug.py $VERBOSE_FLAG --output-dir docs --check-branches
          echo "::endgroup::"
          
          # Save log to debug logs directory
          cp github-pages-debug.log debug_logs/post-generation-debug.log
          
          echo "::notice title=Post-Generation Debug::Debug report generated after content creation"
      
      - name: Inject COMMENT_API_TOKEN into gallery JS
        run: |
          if [ -f "docs/assets/js/gallery.js" ]; then
            # Replace the placeholder token with the actual COMMENT_API_TOKEN
            sed -i "s/{{COMMENT_API_TOKEN}}/${{ secrets.COMMENT_API_TOKEN }}/g" docs/assets/js/gallery.js
            echo "::notice title=Token Injection::Successfully injected COMMENT_API_TOKEN into gallery.js"
          else
            echo "::warning::gallery.js file not found for token injection"
          fi
      
      - name: Upload Debug Logs Artifact
        uses: actions/upload-artifact@v4
        with:
          name: github-pages-debug-logs
          path: debug_logs/
          retention-days: 7
      
      - name: Setup Git Configuration
        run: |
          # Configure Git
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
          # Check if gh-pages branch exists
          if git ls-remote --heads origin gh-pages | grep gh-pages; then
            echo "::notice title=Branch Check::gh-pages branch already exists"
          else
            echo "::notice title=Branch Check::gh-pages branch does not exist, will be created"
          fi
      
      - name: Deploy to gh-pages Branch
        run: |
          # Create a temporary directory for the gh-pages content
          GH_PAGES_DIR=$(mktemp -d)
          
          # Copy the docs directory to the temporary directory
          cp -r docs/* $GH_PAGES_DIR/
          
          # Also create a temporary directory for log files
          LOG_BACKUP_DIR=$(mktemp -d)
          
          # Move log files to the backup directory to prevent conflicts
          if [ -f "content_generation.log" ]; then
            mv content_generation.log $LOG_BACKUP_DIR/
          fi
          if [ -f "github-pages-debug.log" ]; then
            mv github-pages-debug.log $LOG_BACKUP_DIR/
          fi
          if [ -d "debug_logs" ]; then
            cp -r debug_logs/* $LOG_BACKUP_DIR/ || true
            rm -rf debug_logs
          fi
          
          # Save the current commit SHA for reference
          CURRENT_COMMIT=$(git rev-parse HEAD)
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          echo "::notice title=Branch Info::Current branch is ${CURRENT_BRANCH}, commit ${CURRENT_COMMIT}"
          
          # Check if gh-pages branch exists locally
          if git show-ref --verify --quiet refs/heads/gh-pages; then
            # Branch exists locally, checkout
            # First, clean up any untracked files that might prevent checkout
            git clean -fd
            git checkout gh-pages
          else
            # Branch doesn't exist locally, create and checkout
            git checkout --orphan gh-pages
            git rm -rf . || true
          fi
          
          # Check if gh-pages branch exists remotely
          if git ls-remote --heads origin gh-pages | grep gh-pages; then
            echo "::notice title=Remote Branch::Remote gh-pages branch exists, synchronizing"
            
            # Fetch the latest changes from remote
            git fetch origin gh-pages
            
            # Check if we need to create the branch or sync with remote
            if git show-ref --verify --quiet refs/heads/gh-pages; then
              # If we have a local gh-pages branch, reset it to match origin/gh-pages
              git reset --hard origin/gh-pages
            else
              # Create a new branch tracking the remote
              # First, clean up any untracked files that might prevent checkout
              git clean -fd
              git checkout -b gh-pages origin/gh-pages
              git rm -rf . || true
            fi
          fi
          
          # Copy the content from the temporary directory
          cp -r $GH_PAGES_DIR/* .
          
          # Clean up any potential untracked files from previous runs
          find . -type f -not -path "./.git/*" -not -path "./_site/*" | grep -v -E '\.html$|\.css$|\.js$|\.md$|\.yml$|\.json$|\.svg$|\.png$|\.jpg$|\.jpeg$|\.gif$|\.ico$' | xargs rm -f || true
          
          # Add all files
          git add .
          
          # Commit changes with a meaningful message including the source commit
          git commit -m "Update GitHub Pages from commit ${CURRENT_COMMIT}" --allow-empty
          
          # Force push to gh-pages branch if needed (use with caution)
          echo "::notice title=Pushing Changes::Pushing content to gh-pages branch"
          git push -f origin gh-pages
          
          # Return to the previous branch - this is the part that's failing
          # Instead of using the shorthand '-', use the branch name we saved earlier
          if [ "${CURRENT_BRANCH}" != "HEAD" ]; then
            echo "::notice title=Branch Return::Returning to ${CURRENT_BRANCH} branch"
            git checkout ${CURRENT_BRANCH} || echo "::warning::Could not return to ${CURRENT_BRANCH}, but gh-pages was updated successfully"
          else
            echo "::notice title=Branch Return::Was in detached HEAD state, not returning to a branch"
          fi
          
          # Restore log files from backup
          mkdir -p debug_logs
          if [ -d "$LOG_BACKUP_DIR" ]; then
            cp -r $LOG_BACKUP_DIR/* . || true
            if [ -f "$LOG_BACKUP_DIR/content_generation.log" ]; then
              cp $LOG_BACKUP_DIR/content_generation.log .
            fi
            if [ -f "$LOG_BACKUP_DIR/github-pages-debug.log" ]; then
              cp $LOG_BACKUP_DIR/github-pages-debug.log .
            fi
            # Move non-file specific logs to debug_logs
            for f in $LOG_BACKUP_DIR/*; do
              if [ -f "$f" ] && [ "$(basename "$f")" != "content_generation.log" ] && [ "$(basename "$f")" != "github-pages-debug.log" ]; then
                cp "$f" debug_logs/
              fi
            done
          fi
          
          echo "::notice title=Content Deployment Success::Content successfully pushed to gh-pages branch"
          echo "::notice title=Next Steps::The deployment workflow on gh-pages branch will now handle the GitHub Pages deployment" 