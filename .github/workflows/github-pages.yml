name: GitHub Pages Deployment

on:
  schedule:
    - cron: '0 * * * *'  # Runs every hour
  workflow_dispatch:  # Allows manual trigger

permissions:
  contents: write
  pages: write
  id-token: write

# Allow only one concurrent deployment
concurrency:
  group: "pages"
  cancel-in-progress: false

env:
  MY_GITHUB_TOKEN: ${{ secrets.MY_GITHUB_TOKEN }}
  WORKFLOW_PAT: ${{ secrets.WORKFLOW_PAT }}
  DEBUG_LEVEL: "info"  # Can be set to debug, info, warning, error, critical

jobs:
  build:
    runs-on: ubuntu-latest
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for git operations
      
      - name: Identify Workflow Trigger
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "This is a manual workflow run triggered by ${{ github.actor }}"
            echo "MANUAL=true" >> $GITHUB_ENV
            echo "DEBUG_LEVEL=debug" >> $GITHUB_ENV
            echo "::notice title=Manual Trigger::GitHub Pages update manually triggered by ${{ github.actor }}"
          else
            echo "This is a scheduled workflow run"
            echo "MANUAL=false" >> $GITHUB_ENV
            echo "::notice title=Scheduled Trigger::GitHub Pages update triggered by schedule"
          fi
          echo "GITHUB_PAGES_UPDATE_TIMESTAMP=$(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_ENV
          echo "::notice title=Deployment Start::GitHub Pages update started at $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10"
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 markdown jinja2
          sudo apt-get update && sudo apt-get install -y jq
          
          # Create scripts directory if it doesn't exist
          mkdir -p .github/workflows/scripts
          chmod +x .github/workflows/scripts/pages-debug.py
          
          echo "::notice title=Dependencies::All dependencies installed successfully"
      
      - name: Setup Debug Mode
        run: |
          if [[ "$DEBUG_LEVEL" == "debug" ]]; then
            echo "::notice title=Debug Mode::Running in debug mode with verbose logging"
            echo "VERBOSE_FLAG=--verbose" >> $GITHUB_ENV
          else
            echo "VERBOSE_FLAG=" >> $GITHUB_ENV
          fi
          
      - name: Pre-Generation Debug Report
        run: |
          echo "::group::Pre-Generation Debug Info"
          python .github/workflows/scripts/pages-debug.py $VERBOSE_FLAG --check-branches
          echo "::endgroup::"
          
          # Create artifact directory for logs
          mkdir -p debug_logs
          cp github-pages-debug.log debug_logs/pre-generation-debug.log
          
          echo "::notice title=Pre-Generation Debug::Debug report generated before content creation"
          
      - name: Generate GitHub Pages Content
        id: generate-content
        run: |
          mkdir -p docs/assets/css
          mkdir -p docs/assets/js
          
          # Create CSS file for styling
          cat > docs/assets/css/style.css << 'EOL'
          body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #24292e;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
          }
          
          h1, h2, h3 {
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
          }
          
          .release-card {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 16px;
            background-color: #f6f8fa;
          }
          
          .release-card h3, .release-card h4 {
            margin-top: 0;
            border-bottom: none;
          }
          
          .stats-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
          }
          
          .stat-card {
            flex: 1;
            min-width: 150px;
            background-color: #f6f8fa;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 16px;
            text-align: center;
          }
          
          .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #0366d6;
          }
          
          .release-group {
            margin-bottom: 30px;
          }
          
          table.releases-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
          }
          
          table.releases-table, table.releases-table th, table.releases-table td {
            border: 1px solid #e1e4e8;
          }
          
          table.releases-table th, table.releases-table td {
            padding: 8px 12px;
            text-align: left;
          }
          
          table.releases-table th {
            background-color: #f6f8fa;
            font-weight: 600;
          }
          
          table.releases-table tr:nth-child(even) {
            background-color: #f6f8fa;
          }
          
          table.releases-table tr:hover {
            background-color: #f1f8ff;
          }
          
          .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eaecef;
            text-align: center;
            font-size: 12px;
            color: #6a737d;
          }
          EOL
          
          # Create JS file for interactive features
          cat > docs/assets/js/main.js << 'EOL'
          document.addEventListener('DOMContentLoaded', function() {
            // Add any interactive features here
            console.log('GitHub Pages for NOCTURN X-ray loaded');
            
            // Add click event to expandable sections if needed
            const expandButtons = document.querySelectorAll('.expand-button');
            expandButtons.forEach(button => {
              button.addEventListener('click', function() {
                const content = this.nextElementSibling;
                content.style.display = content.style.display === 'none' ? 'block' : 'none';
                this.textContent = content.style.display === 'none' ? 'Show Details' : 'Hide Details';
              });
            });
          });
          EOL
          
          # Generate the index.md file with release information
          python - << 'EOL'
          import os
          import json
          import glob
          import logging
          import re
          import subprocess
          from datetime import datetime
          from collections import defaultdict
          
          # Setup logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
              handlers=[
                  logging.StreamHandler(),
                  logging.FileHandler('content_generation.log')
              ]
          )
          logger = logging.getLogger('content-generator')
          
          if os.environ.get('DEBUG_LEVEL') == 'debug':
              logger.setLevel(logging.DEBUG)
          
          def get_github_releases():
              """Get all GitHub releases using git command"""
              logger.info("Fetching GitHub releases")
              
              try:
                  # Fetch all tags
                  subprocess.run(["git", "fetch", "--tags"], check=True)
                  
                  # Get all tags
                  result = subprocess.run(
                      ["git", "tag", "-l"], 
                      capture_output=True, 
                      text=True, 
                      check=True
                  )
                  tags = result.stdout.strip().split('\n')
                  logger.info(f"Found {len(tags)} tags")
                  
                  # Process each tag
                  releases = []
                  release_types = defaultdict(int)
                  
                  for tag in tags:
                      if not tag:
                          continue
                      
                      # Extract release type and date from tag
                      release_type = None
                      date = None
                      
                      # Pattern matching for different release types
                      patterns = [
                          (r'(ct_to_text_analysis|ct-to-text-analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT to Text Analysis'),
                          (r'(daily-check|daily_check)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Daily Check'),
                          (r'(daily)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Daily'),
                          (r'(morphosource-updates|morphosource_updates)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Updates'),
                          (r'(morphosource-modified|morphosource_modified)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Modified'),
                          (r'(morphosource-check)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'MorphoSource Check'),
                          (r'(ct-image-analysis|ct_image_analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT Image Analysis'),
                          (r'(ct-slice-analysis|ct_slice_analysis)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'CT Slice Analysis'),
                          (r'(monthly-collection)-(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})', 'Monthly Collection'),
                          (r'(ct_analysis_error)-(\d+)', 'CT Analysis Error'),
                      ]
                      
                      for pattern, type_name in patterns:
                          match = re.search(pattern, tag, re.IGNORECASE)
                          if match:
                              release_type = type_name
                              date = match.group(2)
                              break
                      
                      # Skip releases that don't match our patterns
                      if not release_type or not date:
                          logger.debug(f"Skipping tag {tag} - doesn't match any known release pattern")
                          continue
                      
                      # Get release description
                      try:
                          result = subprocess.run(
                              ["git", "tag", "-l", "-n999", tag], 
                              capture_output=True, 
                              text=True, 
                              check=True
                          )
                          description = result.stdout.strip()
                          # Remove the tag name from the beginning of the description
                          if description.startswith(tag):
                              description = description[len(tag):].strip()
                      except subprocess.CalledProcessError:
                          description = "No description available"
                      
                      # Format date for display (if it's a date-based tag)
                      display_date = date
                      if re.match(r'\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}', date):
                          display_date = date.replace('_', ' ').replace('-', '/')
                      
                      release_info = {
                          'tag': tag,
                          'type': release_type,
                          'date': date,
                          'display_date': display_date,
                          'description': description,
                      }
                      
                      releases.append(release_info)
                      release_types[release_type] += 1
                      
                  # Define a custom sorting function to handle different tag formats
                  def sort_key(x):
                      if re.match(r'\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2}', x['date']):
                          # For date-based tags, convert to a timestamp for sorting
                          return x['date']
                      elif x['date'].isdigit():
                          # For numeric ID tags, pad with zeros for proper sorting
                          return f"{int(x['date']):020d}"
                      else:
                          # Default fallback
                          return x['date']
                          
                  # Sort releases (newest first)
                  releases.sort(key=sort_key, reverse=True)
                  logger.info(f"Processed {len(releases)} releases")
                  
                  return releases, release_types
                  
              except subprocess.CalledProcessError as e:
                  logger.error(f"Error getting GitHub releases: {e}")
                  return [], {}
                  
              except Exception as e:
                  logger.error(f"Unexpected error getting GitHub releases: {e}")
                  return [], {}
          
          def get_latest_releases(data_dir='data', limit=10):
              """Get data from filesystem-based releases (legacy method)"""
              logger.info(f"Searching for legacy release data in {data_dir}")
              # Find all date-based directories
              date_dirs = glob.glob(os.path.join(data_dir, '20*-*-*_*-*-*'))
              
              if not date_dirs:
                  logger.warning(f"No release directories found in {data_dir}")
                  return []
              
              # Sort directories by name (which contains the date)
              date_dirs.sort(reverse=True)
              logger.info(f"Found {len(date_dirs)} release directories, using up to {limit}")
              
              releases = []
              for dir_path in date_dirs[:limit]:
                  logger.debug(f"Processing directory: {dir_path}")
                  release_notes_path = os.path.join(dir_path, 'release_notes.txt')
                  daily_info_path = os.path.join(dir_path, 'daily_info.json')
                  
                  if os.path.exists(release_notes_path):
                      logger.debug(f"Found release notes: {release_notes_path}")
                      with open(release_notes_path, 'r') as f:
                          notes_content = f.read()
                      
                      # Extract date from directory name
                      dir_name = os.path.basename(dir_path)
                      date_str = dir_name.split('_')[0].replace('-', '/')
                      
                      release_info = {
                          'date': date_str,
                          'path': dir_path,
                          'notes': notes_content,
                          'type': 'Daily Check'  # Default to Daily Check for legacy releases
                      }
                      
                      # Add extra info from daily_info.json if available
                      if os.path.exists(daily_info_path):
                          try:
                              logger.debug(f"Found daily info: {daily_info_path}")
                              with open(daily_info_path, 'r') as f:
                                  daily_info = json.load(f)
                              release_info['daily_info'] = daily_info
                          except Exception as e:
                              logger.error(f"Error loading {daily_info_path}: {e}")
                      
                      releases.append(release_info)
                  else:
                      logger.warning(f"No release_notes.txt found in {dir_path}")
              
              logger.info(f"Processed {len(releases)} release directories successfully")
              return releases
          
          def generate_index_md(github_releases, release_types, legacy_releases=[]):
              """Generate the index.md content with all releases organized by type"""
              logger.info("Generating index.md content")
              # Get the timestamp from environment variable
              update_timestamp = os.environ.get('GITHUB_PAGES_UPDATE_TIMESTAMP', datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC'))
              
              # Start building the content
              content = f"""# NOCTURN X-ray Release Information

          This page displays information about the latest data releases for the NOCTURN X-ray project.

          **Last Updated:** {update_timestamp}

          ## Summary Statistics

          <div class="stats-container">
              <div class="stat-card">
                  <div>Total Releases</div>
                  <div class="stat-value">{len(github_releases)}</div>
              </div>
          """
              
              # Add stats for each release type
              for release_type, count in release_types.items():
                  content += f"""    <div class="stat-card">
                  <div>{release_type}</div>
                  <div class="stat-value">{count}</div>
              </div>
          """
              
              # Close the stats container
              content += """</div>

          ## Releases by Type

          <table class="releases-table">
              <tr>
                  <th>Type</th>
                  <th>Date</th>
                  <th>Tag</th>
              </tr>
          """
              
              # Add rows for each release
              for release in github_releases[:50]:  # Limit to 50 most recent
                  content += f"""    <tr>
                  <td>{release['type']}</td>
                  <td>{release['display_date']}</td>
                  <td><a href="https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/{release['tag']}">{release['tag']}</a></td>
              </tr>
          """
              
              # Close the table
              content += """</table>

          ## Recent Releases by Type
          """
              
              # Group releases by type
              releases_by_type = defaultdict(list)
              for release in github_releases:
                  releases_by_type[release['type']].append(release)
              
              # Add sections for each type
              for release_type, releases in releases_by_type.items():
                  content += f"""
          ### {release_type}
          
          <div class="release-group">
          """
                  # Add up to 5 most recent releases of this type
                  for release in releases[:5]:
                      content += f"""<div class="release-card">
              <h4>{release['display_date']} - <a href="https://github.com/johntrue15/NOCTURN-X-ray-repo/releases/tag/{release['tag']}">{release['tag']}</a></h4>
              
              ```
              {release['description'] if len(release['description']) < 500 else release['description'][:500] + '... (truncated)'}
              ```
          </div>
          """
                  
                  content += """</div>
          """
              
              # Add footer
              content += """
          ## About NOCTURN X-ray

          NOCTURN is a project designed to streamline non-clinical tomographic imaging workflows across various facilities. Each facility may require its own custom scripts or configuration, which is why we have multiple branches for separate facility requirements.

          <div class="footer">
            <p>Â© NOCTURN X-ray Project. Deployed via GitHub Pages.</p>
            <p>This page is automatically updated hourly with the latest release information.</p>
          </div>
          """
              
              logger.info(f"Generated index.md content ({len(content)} characters)")
              return content
          
          # Main execution
          try:
              logger.info("Starting content generation")
              
              # Get GitHub releases
              github_releases, release_types = get_github_releases()
              
              # Get legacy releases for backup
              legacy_releases = get_latest_releases()
              
              if github_releases:
                  # Generate content using GitHub releases
                  index_content = generate_index_md(github_releases, release_types, legacy_releases)
                  
                  with open('docs/index.md', 'w') as f:
                      f.write(index_content)
                  
                  logger.info("Successfully wrote index.md")
              elif legacy_releases:
                  # Fallback to legacy releases if no GitHub releases
                  logger.warning("No GitHub releases found, falling back to legacy releases")
                  release_types = defaultdict(int)
                  release_types['Daily Check'] = len(legacy_releases)
                  
                  # Convert legacy releases to GitHub release format
                  github_style_releases = []
                  for release in legacy_releases:
                      github_style_releases.append({
                          'tag': f"daily-check-{release['date'].replace('/', '-')}",
                          'type': 'Daily Check',
                          'date': release['date'].replace('/', '-'),
                          'display_date': release['date'],
                          'description': release['notes'][:500] if len(release['notes']) > 500 else release['notes']
                      })
                  
                  index_content = generate_index_md(github_style_releases, release_types)
                  
                  with open('docs/index.md', 'w') as f:
                      f.write(index_content)
                  
                  logger.info("Successfully wrote index.md using legacy releases")
              else:
                  logger.error("No releases found, cannot generate content")
                  
                  # Create a fallback index.md
                  with open('docs/index.md', 'w') as f:
                      f.write("""# NOCTURN X-ray Release Information

          **No release data is currently available. Please check back later.**

          This page is automatically updated hourly with the latest release information.
          """)
                  logger.info("Created fallback index.md")
          except Exception as e:
              logger.error(f"Error generating content: {e}")
              raise
          EOL
          
          # Configure Jekyll (_config.yml)
          cat > docs/_config.yml << 'EOL'
          title: NOCTURN X-ray Release Information
          description: Displaying information about the latest data releases for the NOCTURN X-ray project
          theme: jekyll-theme-cayman
          
          # GitHub Pages settings
          github:
            is_project_page: true
            repository_url: https://github.com/johntrue15/NOCTURN-X-ray-repo
          
          # Enable debugging info
          verbose: true
          EOL
          
          # Show generation log
          echo "::group::Content Generation Log"
          cat content_generation.log
          echo "::endgroup::"
          
          # Save log to debug logs directory
          cp content_generation.log debug_logs/
          
          echo "::notice title=Content Generation::GitHub Pages content generated successfully"
      
      - name: Post-Generation Debug Report
        run: |
          echo "::group::Post-Generation Debug Info"
          python .github/workflows/scripts/pages-debug.py $VERBOSE_FLAG --output-dir docs --check-branches
          echo "::endgroup::"
          
          # Save log to debug logs directory
          cp github-pages-debug.log debug_logs/post-generation-debug.log
          
          echo "::notice title=Post-Generation Debug::Debug report generated after content creation"
      
      - name: Upload Debug Logs Artifact
        uses: actions/upload-artifact@v4
        with:
          name: github-pages-debug-logs
          path: debug_logs/
          retention-days: 7
      
      - name: Setup Git Configuration
        run: |
          # Configure Git
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
          
          # Check if gh-pages branch exists
          if git ls-remote --heads origin gh-pages | grep gh-pages; then
            echo "::notice title=Branch Check::gh-pages branch already exists"
          else
            echo "::notice title=Branch Check::gh-pages branch does not exist, will be created"
          fi
      
      - name: Deploy to gh-pages Branch
        run: |
          # Create a temporary directory for the gh-pages content
          GH_PAGES_DIR=$(mktemp -d)
          
          # Copy the docs directory to the temporary directory
          cp -r docs/* $GH_PAGES_DIR/
          
          # Also create a temporary directory for log files
          LOG_BACKUP_DIR=$(mktemp -d)
          
          # Move log files to the backup directory to prevent conflicts
          if [ -f "content_generation.log" ]; then
            mv content_generation.log $LOG_BACKUP_DIR/
          fi
          if [ -f "github-pages-debug.log" ]; then
            mv github-pages-debug.log $LOG_BACKUP_DIR/
          fi
          if [ -d "debug_logs" ]; then
            cp -r debug_logs/* $LOG_BACKUP_DIR/ || true
            rm -rf debug_logs
          fi
          
          # Save the current commit SHA for reference
          CURRENT_COMMIT=$(git rev-parse HEAD)
          CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
          
          echo "::notice title=Branch Info::Current branch is ${CURRENT_BRANCH}, commit ${CURRENT_COMMIT}"
          
          # Check if gh-pages branch exists locally
          if git show-ref --verify --quiet refs/heads/gh-pages; then
            # Branch exists locally, checkout
            # First, clean up any untracked files that might prevent checkout
            git clean -fd
            git checkout gh-pages
          else
            # Branch doesn't exist locally, create and checkout
            git checkout --orphan gh-pages
            git rm -rf . || true
          fi
          
          # Check if gh-pages branch exists remotely
          if git ls-remote --heads origin gh-pages | grep gh-pages; then
            echo "::notice title=Remote Branch::Remote gh-pages branch exists, synchronizing"
            
            # Fetch the latest changes from remote
            git fetch origin gh-pages
            
            # Check if we need to create the branch or sync with remote
            if git show-ref --verify --quiet refs/heads/gh-pages; then
              # If we have a local gh-pages branch, reset it to match origin/gh-pages
              git reset --hard origin/gh-pages
            else
              # Create a new branch tracking the remote
              # First, clean up any untracked files that might prevent checkout
              git clean -fd
              git checkout -b gh-pages origin/gh-pages
              git rm -rf . || true
            fi
          fi
          
          # Copy the content from the temporary directory
          cp -r $GH_PAGES_DIR/* .
          
          # Clean up any potential untracked files from previous runs
          find . -type f -not -path "./.git/*" -not -path "./_site/*" | grep -v -E '\.html$|\.css$|\.js$|\.md$|\.yml$|\.json$|\.svg$|\.png$|\.jpg$|\.jpeg$|\.gif$|\.ico$' | xargs rm -f || true
          
          # Add all files
          git add .
          
          # Commit changes with a meaningful message including the source commit
          git commit -m "Update GitHub Pages from commit ${CURRENT_COMMIT}" --allow-empty
          
          # Force push to gh-pages branch if needed (use with caution)
          echo "::notice title=Pushing Changes::Pushing content to gh-pages branch"
          git push -f origin gh-pages
          
          # Return to the previous branch - this is the part that's failing
          # Instead of using the shorthand '-', use the branch name we saved earlier
          if [ "${CURRENT_BRANCH}" != "HEAD" ]; then
            echo "::notice title=Branch Return::Returning to ${CURRENT_BRANCH} branch"
            git checkout ${CURRENT_BRANCH} || echo "::warning::Could not return to ${CURRENT_BRANCH}, but gh-pages was updated successfully"
          else
            echo "::notice title=Branch Return::Was in detached HEAD state, not returning to a branch"
          fi
          
          # Restore log files from backup
          mkdir -p debug_logs
          if [ -d "$LOG_BACKUP_DIR" ]; then
            cp -r $LOG_BACKUP_DIR/* . || true
            if [ -f "$LOG_BACKUP_DIR/content_generation.log" ]; then
              cp $LOG_BACKUP_DIR/content_generation.log .
            fi
            if [ -f "$LOG_BACKUP_DIR/github-pages-debug.log" ]; then
              cp $LOG_BACKUP_DIR/github-pages-debug.log .
            fi
            # Move non-file specific logs to debug_logs
            for f in $LOG_BACKUP_DIR/*; do
              if [ -f "$f" ] && [ "$(basename "$f")" != "content_generation.log" ] && [ "$(basename "$f")" != "github-pages-debug.log" ]; then
                cp "$f" debug_logs/
              fi
            done
          fi
          
          echo "::notice title=Deployment Success::Content deployed to gh-pages branch"
      
      - name: Configure GitHub Pages
        uses: actions/configure-pages@v4
        
      - name: Upload GitHub Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: docs
          
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
        
      - name: Deployment summary
        run: |
          echo "::notice title=Deployment Success::GitHub Pages deployed successfully from gh-pages branch"
          echo "::notice title=Deployment URL::View the site at ${{ steps.deployment.outputs.page_url }}"
          
          # Check if GitHub Pages is already configured
          if [[ -z "${{ steps.deployment.outputs.page_url }}" ]]; then
            echo "::warning title=GitHub Pages Configuration::It appears GitHub Pages might not be fully configured yet."
            echo "::warning::Please ensure you've configured GitHub Pages in your repository settings:"
            echo "::warning::1. Go to your repository on GitHub"
            echo "::warning::2. Navigate to Settings > Pages"
            echo "::warning::3. Under 'Build and deployment', set Source to 'GitHub Actions'"
            echo "::warning::4. Save the settings"
          fi
          
          # Save deployment info to debug logs
          echo "Deployment URL: ${{ steps.deployment.outputs.page_url }}" > debug_logs/deployment_info.txt
          echo "Expected URL: https://johntrue15.github.io/NOCTURN-X-ray-repo/" >> debug_logs/deployment_info.txt
          echo "Deployed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> debug_logs/deployment_info.txt
          echo "Deployed from branch: gh-pages" >> debug_logs/deployment_info.txt 